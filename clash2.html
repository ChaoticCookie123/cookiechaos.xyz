<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clash Royale JS Clone - Fixed Towers & Bridges</title>
    
    <style>
        /* --- CSS STYLES --- */
        :root {
            --arena-color: #38761D;       /* Green Arena */
            --river-color: #4A86E8;       /* Blue River */
            --tower-area-color: #5B4F46;  /* Dark Brown/Stone for Tower Areas */
            --hand-bg-color: #333;        /* Dark Grey for Hand/Elixir UI */
            --card-color: #8E7CC3;        /* Purple Card */
        }

        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #222;
            font-family: Arial, sans-serif;
        }

        #game-container {
            width: 600px; 
            height: 900px; 
            border: 5px solid #000;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            background-color: var(--tower-area-color);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        /* --- ARENA (The playing field) --- */

        #arena {
            flex-grow: 1; 
            background-color: var(--arena-color);
            position: relative;
            border-top: 5px solid var(--river-color);
            border-bottom: 5px solid var(--river-color);
            cursor: default;
        }
        #arena.placing {
            cursor: crosshair; 
        }

        .side {
            height: 100px; 
            background-color: var(--tower-area-color);
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 0 10px;
            position: relative; 
            /* Hide the original tower placeholder divs */
            visibility: hidden; 
        }
        #player-side { visibility: hidden; }
        #opponent-side { visibility: hidden; }


        .tower, .king-tower {
            /* Now positioned ABSOLUTE within the arena */
            position: absolute; 
            width: 80px;
            height: 80px;
            background-color: #a0a0a0; 
            border: 3px solid #333;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 30px; 
            cursor: default;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.4);
            color: #fff;
            z-index: 20; /* Higher than troops */
        }

        .health-bar {
            position: absolute;
            top: 5px;
            width: 70px;
            height: 5px;
            background-color: red;
            border: 1px solid #000;
            border-radius: 3px;
        }
        .health-fill {
            height: 100%;
            background-color: green;
            transition: width 0.1s; 
            border-radius: 3px;
        }

        /* River and Bridges */
        #arena::before {
            content: '';
            position: absolute;
            top: calc(50% - 5px); 
            left: 0;
            right: 0;
            height: 10px;
            background-color: var(--river-color);
            z-index: 1;
            box-shadow: 0 0 10px rgba(0, 0, 255, 0.5);
        }

        .bridge {
            position: absolute;
            width: 40px;
            height: 10px;
            background-color: #996633; 
            z-index: 2;
            top: calc(50% - 5px);
            border-radius: 2px;
            transition: opacity 0.3s;
        }
        #bridge-1 { left: 150px; }
        #bridge-2 { left: 410px; } /* Corrected placement */

        /* --- UI (Hand and Elixir) --- */

        #game-ui {
            height: 120px;
            background-color: var(--hand-bg-color);
            display: flex;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
            border-top: 5px solid #000;
        }

        #elixir-bar {
            background-color: #FFC000; 
            color: #000;
            padding: 10px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 20px;
            width: 80px;
            text-align: center;
            margin-right: 20px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.5);
        }

        #card-hand {
            display: flex;
            gap: 15px; 
        }

        .card {
            width: 80px;
            height: 100px;
            background-color: var(--card-color);
            border: 4px solid #fff;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            align-items: center;
            cursor: pointer;
            transition: transform 0.1s, border-color 0.1s;
            user-select: none;
            position: relative; 
            z-index: 50; 
        }

        .card.active-to-place {
            border-color: yellow;
            box-shadow: 0 0 15px yellow;
            transform: translateY(-5px);
        }
        
        .card.disabled {
            filter: grayscale(100%);
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .card-emoji {
            font-size: 36px;
            margin-top: 5px;
        }

        .card-cost {
            background-color: #333;
            color: white;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            font-size: 16px;
            line-height: 25px;
            text-align: center;
            position: absolute;
            bottom: -12px; 
            border: 2px solid var(--card-color);
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        /* Troop Styling */
        .troop {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            z-index: 10;
        }
        .player-troop { background-color: #008000; border: 2px solid #000; }
        .opponent-troop { background-color: #FF0000; border: 2px solid #000; }
        .troop-health {
            position: absolute;
            bottom: -5px;
            width: 20px;
            height: 3px;
            background-color: red;
        }
        .troop-health-fill {
            height: 100%;
            background-color: limegreen;
        }

        /* DAMAGE TEXT VISUALIZATION */
        .damage-text {
            position: absolute;
            color: white;
            font-weight: bold;
            font-size: 16px;
            text-shadow: 1px 1px 2px black;
            animation: floatUpAndFade 1s forwards;
            pointer-events: none; 
            z-index: 100;
        }

        @keyframes floatUpAndFade {
            0% {
                transform: translateY(0);
                opacity: 1;
            }
            100% {
                transform: translateY(-50px);
                opacity: 0;
            }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="opponent-side" class="side">
            </div>

        <div id="arena">
            <div id="bridge-1" class="bridge" data-lane="left"></div>
            <div id="bridge-2" class="bridge" data-lane="right"></div>
            </div>

        <div id="player-side" class="side">
            </div>

        <div id="game-ui">
            <div id="elixir-bar">
                <span id="elixir-count">0</span> / 10
            </div>
            <div id="card-hand">
                </div>
        </div>
    </div>

    <script>
        // --- JAVASCRIPT LOGIC ---

        // --- 1. GAME CONSTANTS AND DATA ---
        const CARD_DEFINITIONS = [
            { name: "Knight", cost: 3, emoji: "üõ°Ô∏è", type: "troop", hp: 600, dmg: 50, range: 40, attackSpeed: 10 },
            { name: "Archers", cost: 3, emoji: "üèπ", type: "troop", hp: 300, dmg: 40, range: 200, attackSpeed: 15 },
            { name: "Giant", cost: 5, emoji: "üóø", type: "troop", hp: 1200, dmg: 70, range: 40, attackSpeed: 12 },
            { name: "Fireball", cost: 4, emoji: "üî•", type: "spell", dmg: 300 },
        ];

        const HAND_SIZE = 4;
        const GAME_TICK_RATE = 50; 
        const TROOP_MOVEMENT_SPEED = 1.5; 
        const TROOP_SIZE_HALF = 15; 
        const TOWER_SIZE_HALF = 40; // Tower size is 80px

        let playerElixir = 5;
        let playerHand = [];
        let cardToPlaceIndex = -1; 
        let activeTroops = []; 
        const TOWERS = {}; 
        
        // Waypoint Y-coordinates slightly adjusted for better pathing towards the bridges
        const WAYPOINTS = {
            'P-LEFT-WAYPOINT': { x: 170, y: 450, bridge: 'left' }, // Player side (bottom half)
            'P-RIGHT-WAYPOINT': { x: 430, y: 450, bridge: 'right' },
            'O-LEFT-WAYPOINT': { x: 170, y: 250, bridge: 'left' }, // Opponent side (top half)
            'O-RIGHT-WAYPOINT': { x: 430, y: 250, bridge: 'right' },
        };
        
        const BRIDGE_STATE = {
            'left': { element: document.getElementById('bridge-1'), isDestroyed: false, associatedTowerId: 'O-L' },
            'right': { element: document.getElementById('bridge-2'), isDestroyed: false, associatedTowerId: 'O-R' }
        };


        // --- 2. DOM ELEMENTS ---
        const arena = document.getElementById('arena');
        const cardHandDiv = document.getElementById('card-hand');
        const elixirCountSpan = document.getElementById('elixir-count');

        // --- 3. CORE UTILITIES ---

        function updateHealthBar(gameObject, currentHP, maxHP) {
            const percentage = (currentHP / maxHP) * 100;
            const fillElement = gameObject.element.querySelector(gameObject.isTower ? '.health-fill' : '.troop-health-fill');
            if (fillElement) {
                fillElement.style.width = `${Math.max(0, percentage)}%`;
            }
        }
        
        function showDamageText(targetObject, amount) {
            const damageElement = document.createElement('div');
            damageElement.className = 'damage-text';
            damageElement.textContent = Math.round(amount);
            
            let baseX = targetObject.x;
            let baseY = targetObject.y;
            
            // Towers and Troops are now positioned directly in the Arena, making this simpler.
            if (targetObject.isTower) {
                baseY -= TOWER_SIZE_HALF; 
            } else {
                baseY -= TROOP_SIZE_HALF; 
            }

            damageElement.style.left = `${baseX - TROOP_SIZE_HALF}px`;
            damageElement.style.top = `${baseY}px`;
            
            arena.appendChild(damageElement);

            setTimeout(() => {
                damageElement.remove();
            }, 1000);
        }


        function findClosestTarget(sourceTroop) {
            const enemySide = sourceTroop.side === 'player' ? 'opponent' : 'player';
            const targets = activeTroops.filter(t => t.side === enemySide && t.hp > 0);
            
            Object.values(TOWERS).forEach(tower => {
                if (tower.side === enemySide && tower.hp > 0) {
                    targets.push(tower);
                }
            });

            let closestTarget = null;
            let minDistanceSq = Infinity;
            const rangeSq = sourceTroop.range * sourceTroop.range;

            targets.forEach(target => {
                const dx = target.x - sourceTroop.x;
                const dy = target.y - sourceTroop.y;
                const distanceSq = dx * dx + dy * dy;

                if (distanceSq < minDistanceSq) { 
                    minDistanceSq = distanceSq;
                    closestTarget = target;
                }
            });
            
            if (minDistanceSq <= rangeSq) {
                 return closestTarget;
            }
            return null; 
        }

        // --- 4. CARD HAND AND UI ---
        
        function drawCard() {
            if (playerHand.length >= HAND_SIZE) return;
            const randomIndex = Math.floor(Math.random() * CARD_DEFINITIONS.length);
            const newCard = { ...CARD_DEFINITIONS[randomIndex] }; 
            playerHand.push(newCard);
            renderHand();
        }

        function updateElixirUI() {
            elixirCountSpan.textContent = playerElixir;
            
            document.querySelectorAll('.card').forEach(cardElement => {
                const index = parseInt(cardElement.getAttribute('data-card-index'));
                const cost = playerHand[index]?.cost || 99;
                
                if (playerElixir < cost) {
                    cardElement.classList.add('disabled');
                } else {
                    cardElement.classList.remove('disabled');
                }
            });
        }

        function renderHand() {
            cardHandDiv.innerHTML = '';
            playerHand.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.className = 'card';
                cardElement.setAttribute('data-card-index', index);
                cardElement.innerHTML = `
                    <span class="card-emoji">${card.emoji}</span>
                    <div class="card-cost">${card.cost}</div>
                `;
                
                cardElement.addEventListener('click', () => handleCardSelection(index));
                cardHandDiv.appendChild(cardElement);
            });
            updateElixirUI();
        }

        // --- 5. CLICK AND PLACE LOGIC ---

        function handleCardSelection(index) {
            const card = playerHand[index];
            if (playerElixir < card.cost) return;

            document.querySelectorAll('.card').forEach(c => c.classList.remove('active-to-place'));
            
            cardToPlaceIndex = index;
            const cardElement = document.querySelector(`.card[data-card-index="${index}"]`);
            cardElement.classList.add('active-to-place');
            arena.classList.add('placing');
        }

        arena.addEventListener('click', (e) => {
            if (cardToPlaceIndex === -1) return; 

            const card = playerHand[cardToPlaceIndex];
            const rect = arena.getBoundingClientRect();
            const arenaX = e.clientX - rect.left;
            const arenaY = e.clientY - rect.top;
            
            const deploymentYThreshold = rect.height * 0.5;
            const isSpell = card.type === 'spell';

            if (!isSpell && arenaY < deploymentYThreshold) {
                return; 
            }
            
            handleCardPlacement(cardToPlaceIndex, arenaX, arenaY);
            
            cardToPlaceIndex = -1;
            document.querySelectorAll('.card').forEach(c => c.classList.remove('active-to-place'));
            arena.classList.remove('placing');
        });

        function handleCardPlacement(cardIndex, x, y) {
            const card = playerHand[cardIndex];
            
            playerElixir -= card.cost;
            playerHand.splice(cardIndex, 1); 
            drawCard(); 
            updateElixirUI();
            
            if (card.type === 'troop') {
                createTroop('player', card, x, y); 
            } else if (card.type === 'spell') {
                applySpellEffect(card, x, y);
            }
        }

        // --- 6. TROOP & COMBAT LOGIC ---

        /** * Determines the pathing destination, factoring in destroyed bridges.
         * If a target bridge is destroyed, the troop is redirected to the active bridge's waypoint.
         */
        function getInitialWaypoint(side, spawnX) {
            const isLeftLane = spawnX < (arena.offsetWidth / 2);
            let lane = isLeftLane ? 'left' : 'right';
            
            let waypointKey = `${side === 'player' ? 'P' : 'O'}-${lane.toUpperCase()}-WAYPOINT`;

            // Check if the primary bridge for this lane is destroyed
            if (BRIDGE_STATE[lane].isDestroyed) {
                // Switch to the other lane
                lane = isLeftLane ? 'right' : 'left';
                waypointKey = `${side === 'player' ? 'P' : 'O'}-${lane.toUpperCase()}-WAYPOINT`;

                // If the troop was placed too far to successfully path to the other lane,
                // we might need a more complex pathfinder, but for now, we force the path.
            }
            
            return WAYPOINTS[waypointKey];
        }

        function createTroop(side, card, x, y) {
            const troopElement = document.createElement('div');
            troopElement.className = `troop ${side}-troop`;
            troopElement.textContent = card.emoji;
            troopElement.style.left = `${x - TROOP_SIZE_HALF}px`;
            troopElement.style.top = `${y - TROOP_SIZE_HALF}px`;
            
            troopElement.innerHTML += '<div class="troop-health"><div class="troop-health-fill" style="width:100%"></div></div>';
            
            arena.appendChild(troopElement);

            const arenaHeight = arena.offsetHeight;
            const riverCenterY = arenaHeight / 2;
            const deployDistanceToRiver = Math.abs(y - riverCenterY);
            
            let initialDestination = null;
            if (deployDistanceToRiver > 100) { 
                 initialDestination = getInitialWaypoint(side, x);
            } else {
                 // If close to the river/bridge, target the primary tower directly
                 const targetTowerId = side === 'player' ? 'O-L' : 'P-L'; 
                 initialDestination = TOWERS[targetTowerId];
            }


            const newTroop = {
                id: Math.random(),
                side: side,
                element: troopElement,
                x: x, 
                y: y, 
                hp: card.hp,
                maxHp: card.hp,
                dmg: card.dmg,
                range: card.range,
                speed: TROOP_MOVEMENT_SPEED, 
                target: null, 
                currentDestination: initialDestination, 
                isAttacking: false,
                attackCooldown: 0,
                attackSpeed: card.attackSpeed, 
                isTower: false,
            };
            
            activeTroops.push(newTroop);
        }

        function applySpellEffect(card, x, y) {
             const spellRadius = 150; 
             const radiusSq = spellRadius * spellRadius;

            activeTroops.forEach(troop => {
                if (troop.side === 'opponent') {
                    const dx = troop.x - x;
                    const dy = troop.y - y;
                    const distanceSq = dx * dx + dy * dy;
                    if (distanceSq < radiusSq) {
                         troop.hp -= card.dmg; 
                         showDamageText(troop, card.dmg);
                    }
                }
            });

            Object.values(TOWERS).forEach(tower => {
                if (tower.side === 'opponent' && tower.hp > 0) {
                    const dx = tower.x - x;
                    const dy = tower.y - y;
                    const distanceSq = dx * dx + dy * dy;

                    if (distanceSq < radiusSq) {
                         tower.hp -= card.dmg;
                         updateHealthBar(tower, tower.hp, tower.maxHp);
                         showDamageText(tower, card.dmg);
                    }
                }
            });
             
            // Simple flash effect (omitted for brevity)
        }

        function checkBridgeHealth(towerId) {
            let lane = null;
            if (towerId === 'O-L') lane = 'left';
            if (towerId === 'O-R') lane = 'right';

            if (lane && !BRIDGE_STATE[lane].isDestroyed && TOWERS[towerId].hp <= 0) {
                BRIDGE_STATE[lane].isDestroyed = true;
                BRIDGE_STATE[lane].element.style.opacity = 0; // Visual removal
                console.log(`${lane.toUpperCase()} bridge is destroyed!`);
            }
        }


        // --- 7. MAIN GAME LOOP (Movement/Combat logic) ---

        function gameLoop() {
            activeTroops.forEach(troop => {
                if (troop.hp <= 0) return; 

                // 1. Target check (Highest Priority)
                if (!troop.target || troop.target.hp <= 0) {
                    troop.target = findClosestTarget(troop);
                }

                if (troop.target && troop.target.hp > 0) {
                    const dx = troop.target.x - troop.x;
                    const dy = troop.target.y - troop.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Attack or move towards TARGET
                    if (distance <= troop.range) {
                        troop.isAttacking = true;
                        if (troop.attackCooldown <= 0) {
                            troop.target.hp -= troop.dmg;
                            troop.attackCooldown = troop.attackSpeed; 
                            
                            updateHealthBar(troop.target, troop.target.hp, troop.target.maxHp);
                            showDamageText(troop.target, troop.dmg);
                        }
                    } else {
                        // Move straight toward the enemy troop/tower target (overrides pathfinding)
                        troop.isAttacking = false;
                        const ratio = troop.speed / distance;
                        troop.x += dx * ratio;
                        troop.y += dy * ratio;
                    }
                } else {
                    // 2. Pathfinding (Lower Priority - only if no enemy in range)
                    
                    let destination = troop.currentDestination;
                    let targetTowerId = troop.side === 'player' ? 'O-L' : 'P-L'; // Default target 

                    // --- Dynamic Path Re-evaluation ---
                    if (!destination || (destination.isTower && destination.hp <= 0)) {
                         // Find the best tower target
                        if (TOWERS['O-L'].hp > 0) targetTowerId = 'O-L';
                        else if (TOWERS['O-R'].hp > 0) targetTowerId = 'O-R';
                        else targetTowerId = 'O-K';
                        
                        // Set the new destination (either primary tower or king)
                        destination = TOWERS[targetTowerId];
                        troop.currentDestination = destination;
                    }


                    // Move toward the current path destination
                    if (destination) {
                        const dx = destination.x - troop.x;
                        const dy = destination.y - troop.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Check if waypoint reached (only relevant if destination is a waypoint, not a tower)
                        if (destination.bridge && distance < 10) {
                            // Reached Waypoint, now set target to nearest active tower
                            troop.currentDestination = TOWERS[targetTowerId]; 
                            destination = troop.currentDestination;
                        }

                        if (distance > 5) { 
                            const ratio = troop.speed / distance;
                            troop.x += dx * ratio;
                            troop.y += dy * ratio;
                        }
                    }
                }

                if (troop.attackCooldown > 0) {
                    troop.attackCooldown--;
                }
                troop.element.style.left = `${troop.x - TROOP_SIZE_HALF}px`;
                troop.element.style.top = `${troop.y - TROOP_SIZE_HALF}px`;
                updateHealthBar(troop, troop.hp, troop.maxHp);
            });

            // --- 7.2 Cleanup Dead Units/Towers ---
            activeTroops = activeTroops.filter(troop => {
                if (troop.hp <= 0) {
                    troop.element.remove();
                    return false;
                }
                return true;
            });
            
            Object.keys(TOWERS).forEach(id => {
                 const tower = TOWERS[id];
                 if (tower.hp <= 0) {
                    if (tower.element.textContent !== 'üí•') {
                        tower.element.textContent = 'üí•';
                        tower.element.style.opacity = '0.4';
                        tower.element.querySelector('.health-bar').style.display = 'none';
                        // Check if a bridge should be destroyed
                        checkBridgeHealth(id); 
                    }
                    // Keep tower in TOWERS list but make it untargetable by adjusting coordinates
                    // We only do this if it's NOT the King Tower, so King Tower remains visible for final win condition
                    if (id !== 'O-K' && id !== 'P-K') {
                        tower.x = -1000; 
                        tower.y = -1000;
                    }
                 }
            });
        }

        // --- 8. INITIALIZATION ---

        function initTowers() {
            const arenaHeight = arena.offsetHeight;
            
            // Define all tower properties here
            const towerData = [
                { id: 'O-L', isKing: false, maxHp: 1000, x: 170 + TOWER_SIZE_HALF, y: 50 + TOWER_SIZE_HALF, side: 'opponent' },
                { id: 'O-K', isKing: true, maxHp: 1500, x: 300, y: 50 + TOWER_SIZE_HALF, side: 'opponent' },
                { id: 'O-R', isKing: false, maxHp: 1000, x: 430 + TOWER_SIZE_HALF, y: 50 + TOWER_SIZE_HALF, side: 'opponent' },
                { id: 'P-L', isKing: false, maxHp: 1000, x: 170 + TOWER_SIZE_HALF, y: arenaHeight - 50 - TOWER_SIZE_HALF, side: 'player' },
                { id: 'P-K', isKing: true, maxHp: 1500, x: 300, y: arenaHeight - 50 - TOWER_SIZE_HALF, side: 'player' },
                { id: 'P-R', isKing: false, maxHp: 1000, x: 430 + TOWER_SIZE_HALF, y: arenaHeight - 50 - TOWER_SIZE_HALF, side: 'player' },
            ];

            towerData.forEach(data => {
                const el = document.createElement('div');
                el.className = data.isKing ? 'king-tower' : 'tower';
                el.id = data.id;
                el.innerHTML = `${data.isKing ? 'üëë' : 'üè∞'}<div class="health-bar"><div class="health-fill"></div></div>`;
                
                el.style.left = `${data.x - TOWER_SIZE_HALF}px`;
                el.style.top = `${data.y - TOWER_SIZE_HALF}px`;
                
                arena.appendChild(el);

                const tower = {
                    id: data.id,
                    side: data.side,
                    element: el,
                    hp: data.maxHp,
                    maxHp: data.maxHp,
                    dmg: 0, 
                    range: 0, 
                    x: data.x,
                    y: data.y,
                    isTower: true,
                };
                TOWERS[data.id] = tower;
                updateHealthBar(tower, tower.hp, tower.maxHp);
            });
        }


        function opponentAiLoop() {
            setInterval(() => {
                const troopCards = CARD_DEFINITIONS.filter(c => c.type === 'troop').sort((a,b) => a.cost - b.cost);
                
                // --- Simple AI Lane Selection ---
                let spawnX;
                let targetLane;

                if (TOWERS['P-L'].hp > TOWERS['P-R'].hp && TOWERS['P-R'].hp > 0) {
                    targetLane = 'right'; // Attack the weaker right tower
                } else if (TOWERS['P-L'].hp > 0) {
                    targetLane = 'left';
                } else {
                    targetLane = 'right'; 
                }
                
                spawnX = (targetLane === 'left') ? 200 : 400;

                const spawnY = arena.offsetHeight * 0.2; // Spawn high up

                if (troopCards.length > 0) {
                    const cardToPlay = troopCards[0]; 

                    if (Math.random() > 0.2) { 
                        createTroop('opponent', cardToPlay, spawnX, spawnY);
                    }
                }
            }, 3000); 
        }

        function elixirLoop() {
            setInterval(() => {
                if (playerElixir < 10) {
                    playerElixir = Math.min(10, playerElixir + 1);
                    updateElixirUI();
                }
            }, 1000); 
        }

        function initGame() {
            initTowers();
            
            for(let i = 0; i < HAND_SIZE; i++) {
                drawCard();
            }

            setInterval(gameLoop, GAME_TICK_RATE); 
            elixirLoop();
            opponentAiLoop(); 
            
            console.log("Clash Clone Initialized! Towers are on the map and bridges are destructible.");
        }


        window.onload = initGame;
    </script>
</body>
</html>
