<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clash Royale JS Clone - Pathfinding & Damage</title>
    
    <style>
        /* --- CSS STYLES --- */
        :root {
            --arena-color: #38761D; 
            --river-color: #4A86E8; 
            --hand-bg-color: #333;
            --card-color: #8E7CC3; 
        }

        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #222;
        }

        #game-container {
            width: 600px; 
            height: 900px; 
            border: 5px solid #000;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        /* --- ARENA --- */

        #arena {
            flex-grow: 1;
            background-color: var(--arena-color);
            position: relative;
            border-top: 5px solid var(--river-color);
            border-bottom: 5px solid var(--river-color);
            cursor: default;
        }
        #arena.placing {
            cursor: crosshair; 
        }

        .side {
            height: 100px; 
            background-color: var(--arena-color);
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 0 10px;
        }

        .tower, .king-tower {
            font-size: 30px; 
            width: 80px;
            height: 80px;
            background-color: #ccc;
            border: 3px solid #000;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: default;
            position: relative;
        }

        .health-bar {
            position: absolute;
            top: 5px;
            width: 70px;
            height: 5px;
            background-color: red;
            border: 1px solid #000;
        }
        .health-fill {
            height: 100%;
            background-color: green;
            transition: width 0.1s; 
        }

        /* River and Bridges */
        #arena::before {
            content: '';
            position: absolute;
            top: calc(50% - 5px); 
            left: 0;
            right: 0;
            height: 10px;
            background-color: var(--river-color);
            z-index: 1;
        }

        .bridge {
            position: absolute;
            width: 40px;
            height: 10px;
            background-color: #996633; 
            z-index: 2;
            top: calc(50% - 5px);
        }
        #bridge-1 { left: 150px; }
        #bridge-2 { right: 150px; }

        /* Troop Styling */
        .troop {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            z-index: 10;
        }
        .player-troop { background-color: #008000; border: 2px solid #000; }
        .opponent-troop { background-color: #FF0000; border: 2px solid #000; }
        .troop-health {
            position: absolute;
            bottom: -5px;
            width: 20px;
            height: 3px;
            background-color: red;
        }
        .troop-health-fill {
            height: 100%;
            background-color: limegreen;
        }

        /* --- DAMAGE TEXT VISUALIZATION --- */
        .damage-text {
            position: absolute;
            color: white;
            font-weight: bold;
            font-size: 16px;
            text-shadow: 1px 1px 2px black;
            animation: floatUpAndFade 1s forwards;
            pointer-events: none; /* Prevents text from interfering with clicks */
            z-index: 100;
        }

        @keyframes floatUpAndFade {
            0% {
                transform: translateY(0);
                opacity: 1;
            }
            100% {
                transform: translateY(-50px);
                opacity: 0;
            }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="opponent-side" class="side">
            <div id="opponent-left-tower" class="tower" data-id="O-L" data-max-hp="1000">üè∞<div class="health-bar"><div class="health-fill"></div></div></div>
            <div id="opponent-king-tower" class="king-tower" data-id="O-K" data-max-hp="1500">üëë<div class="health-bar"><div class="health-fill"></div></div></div>
            <div id="opponent-right-tower" class="tower" data-id="O-R" data-max-hp="1000">üè∞<div class="health-bar"><div class="health-fill"></div></div></div>
        </div>

        <div id="arena">
            <div id="bridge-1" class="bridge"></div>
            <div id="bridge-2" class="bridge"></div>
        </div>

        <div id="player-side" class="side">
            <div id="player-left-tower" class="tower" data-id="P-L" data-max-hp="1000">üè∞<div class="health-bar"><div class="health-fill"></div></div></div>
            <div id="player-king-tower" class="king-tower" data-id="P-K" data-max-hp="1500">üëë<div class="health-bar"><div class="health-fill"></div></div></div>
            <div id="player-right-tower" class="tower" data-id="P-R" data-max-hp="1000">üè∞<div class="health-bar"><div class="health-fill"></div></div></div>
        </div>

        <div id="game-ui">
            <div id="elixir-bar">
                <span id="elixir-count">0</span> / 10
            </div>
            <div id="card-hand">
                </div>
        </div>
    </div>

    <script>
        // --- JAVASCRIPT LOGIC ---

        // --- 1. GAME CONSTANTS AND DATA ---
        const CARD_DEFINITIONS = [
            { name: "Knight", cost: 3, emoji: "üõ°Ô∏è", type: "troop", hp: 600, dmg: 50, range: 40, attackSpeed: 10 },
            { name: "Archers", cost: 3, emoji: "üèπ", type: "troop", hp: 300, dmg: 40, range: 200, attackSpeed: 15 },
            { name: "Giant", cost: 5, emoji: "üóø", type: "troop", hp: 1200, dmg: 70, range: 40, attackSpeed: 12 },
            { name: "Fireball", cost: 4, emoji: "üî•", type: "spell", dmg: 300 },
        ];

        const HAND_SIZE = 4;
        const GAME_TICK_RATE = 50; 
        const TROOP_MOVEMENT_SPEED = 1.5; 
        const TROOP_SIZE_HALF = 15; // Half width/height of a troop element

        let playerElixir = 5;
        let playerHand = [];
        let cardToPlaceIndex = -1; 
        let activeTroops = []; 
        const TOWERS = {}; 
        
        // Waypoints: Coordinates relative to the Arena center (300px wide, ~700px tall)
        const WAYPOINTS = {
            // Player side waypoints (move UP)
            'P-LEFT-WAYPOINT': { x: 170, y: 460 }, 
            'P-RIGHT-WAYPOINT': { x: 430, y: 460 },
            // Opponent side waypoints (move DOWN)
            'O-LEFT-WAYPOINT': { x: 170, y: 440 },
            'O-RIGHT-WAYPOINT': { x: 430, y: 440 },
        };


        // --- 2. DOM ELEMENTS ---
        const arena = document.getElementById('arena');
        const cardHandDiv = document.getElementById('card-hand');
        const elixirCountSpan = document.getElementById('elixir-count');

        // --- 3. CORE UTILITIES ---

        function updateHealthBar(gameObject, currentHP, maxHP) {
            const percentage = (currentHP / maxHP) * 100;
            const fillElement = gameObject.element.querySelector(gameObject.isTower ? '.health-fill' : '.troop-health-fill');
            if (fillElement) {
                fillElement.style.width = `${Math.max(0, percentage)}%`;
            }
        }
        
        /** Shows damage amount floating up over the arena */
        function showDamageText(targetObject, amount) {
            const damageElement = document.createElement('div');
            damageElement.className = 'damage-text';
            damageElement.textContent = Math.round(amount);
            
            // Position the damage text near the target (adjusting for tower vs troop)
            let baseX = targetObject.x;
            let baseY = targetObject.y;
            
            if (targetObject.isTower) {
                baseY -= 50; // Place above the tower
            } else {
                baseY -= 15; // Place above the troop
            }

            damageElement.style.left = `${baseX - TROOP_SIZE_HALF}px`;
            damageElement.style.top = `${baseY}px`;
            
            arena.appendChild(damageElement);

            // Remove the element after the animation finishes (1 second)
            setTimeout(() => {
                damageElement.remove();
            }, 1000);
        }


        function findClosestTarget(sourceTroop) {
            const enemySide = sourceTroop.side === 'player' ? 'opponent' : 'player';
            const targets = activeTroops.filter(t => t.side === enemySide && t.hp > 0);
            
            Object.values(TOWERS).forEach(tower => {
                if (tower.side === enemySide && tower.hp > 0) {
                    targets.push(tower);
                }
            });

            let closestTarget = null;
            let minDistanceSq = Infinity;
            const rangeSq = sourceTroop.range * sourceTroop.range;

            targets.forEach(target => {
                const dx = target.x - sourceTroop.x;
                const dy = target.y - sourceTroop.y;
                const distanceSq = dx * dx + dy * dy;

                if (distanceSq < minDistanceSq) { 
                    minDistanceSq = distanceSq;
                    closestTarget = target;
                }
            });
            
            if (minDistanceSq <= rangeSq) {
                 return closestTarget;
            }
            return null; 
        }

        // --- 4. CARD HAND AND UI (Same as previous, omitted for brevity) ---
        
        function drawCard() {
            if (playerHand.length >= HAND_SIZE) return;
            const randomIndex = Math.floor(Math.random() * CARD_DEFINITIONS.length);
            const newCard = { ...CARD_DEFINITIONS[randomIndex] }; 
            playerHand.push(newCard);
            renderHand();
        }

        function updateElixirUI() {
            elixirCountSpan.textContent = playerElixir;
            
            document.querySelectorAll('.card').forEach(cardElement => {
                const index = parseInt(cardElement.getAttribute('data-card-index'));
                const cost = playerHand[index]?.cost || 99;
                
                if (playerElixir < cost) {
                    cardElement.classList.add('disabled');
                } else {
                    cardElement.classList.remove('disabled');
                }
            });
        }

        function renderHand() {
            cardHandDiv.innerHTML = '';
            playerHand.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.className = 'card';
                cardElement.setAttribute('data-card-index', index);
                cardElement.innerHTML = `
                    <span class="card-emoji">${card.emoji}</span>
                    <div class="card-cost">${card.cost}</div>
                `;
                
                cardElement.addEventListener('click', () => handleCardSelection(index));
                cardHandDiv.appendChild(cardElement);
            });
            updateElixirUI();
        }

        function handleCardSelection(index) {
            const card = playerHand[index];
            if (playerElixir < card.cost) return;

            document.querySelectorAll('.card').forEach(c => c.classList.remove('active-to-place'));
            
            cardToPlaceIndex = index;
            const cardElement = document.querySelector(`.card[data-card-index="${index}"]`);
            cardElement.classList.add('active-to-place');
            arena.classList.add('placing');
        }

        arena.addEventListener('click', (e) => {
            if (cardToPlaceIndex === -1) return; 

            const card = playerHand[cardToPlaceIndex];
            const rect = arena.getBoundingClientRect();
            const arenaX = e.clientX - rect.left;
            const arenaY = e.clientY - rect.top;
            
            const deploymentYThreshold = rect.height * 0.5;
            const isSpell = card.type === 'spell';

            if (!isSpell && arenaY < deploymentYThreshold) {
                return; 
            }
            
            handleCardPlacement(cardToPlaceIndex, arenaX, arenaY);
            
            cardToPlaceIndex = -1;
            document.querySelectorAll('.card').forEach(c => c.classList.remove('active-to-place'));
            arena.classList.remove('placing');
        });

        function handleCardPlacement(cardIndex, x, y) {
            const card = playerHand[cardIndex];
            
            playerElixir -= card.cost;
            playerHand.splice(cardIndex, 1); 
            drawCard(); 
            updateElixirUI();
            
            if (card.type === 'troop') {
                createTroop('player', card, x, y); 
            } else if (card.type === 'spell') {
                applySpellEffect(card, x, y);
            }
        }

        // --- 6. TROOP & COMBAT LOGIC ---

        /** Determines the initial target waypoint for a new troop to path to the bridge. */
        function getInitialWaypoint(side, spawnX) {
            const isLeftLane = spawnX < (arena.offsetWidth / 2);
            
            if (side === 'player') {
                return isLeftLane ? WAYPOINTS['P-LEFT-WAYPOINT'] : WAYPOINTS['P-RIGHT-WAYPOINT'];
            } else {
                return isLeftLane ? WAYPOINTS['O-LEFT-WAYPOINT'] : WAYPOINTS['O-RIGHT-WAYPOINT'];
            }
        }

        function createTroop(side, card, x, y) {
            const troopElement = document.createElement('div');
            troopElement.className = `troop ${side}-troop`;
            troopElement.textContent = card.emoji;
            troopElement.style.left = `${x - TROOP_SIZE_HALF}px`;
            troopElement.style.top = `${y - TROOP_SIZE_HALF}px`;
            
            troopElement.innerHTML += '<div class="troop-health"><div class="troop-health-fill" style="width:100%"></div></div>';
            
            arena.appendChild(troopElement);

            const initialWaypoint = getInitialWaypoint(side, x);

            const newTroop = {
                id: Math.random(),
                side: side,
                element: troopElement,
                x: x, 
                y: y, 
                hp: card.hp,
                maxHp: card.hp,
                dmg: card.dmg,
                range: card.range,
                speed: TROOP_MOVEMENT_SPEED, 
                target: null, 
                currentDestination: initialWaypoint, // New: Waypoint destination
                isAttacking: false,
                attackCooldown: 0,
                attackSpeed: card.attackSpeed, 
                isTower: false,
            };
            
            activeTroops.push(newTroop);
        }

        function applySpellEffect(card, x, y) {
             const spellRadius = 150; 
             const radiusSq = spellRadius * spellRadius;

            activeTroops.forEach(troop => {
                if (troop.side === 'opponent') {
                    const dx = troop.x - x;
                    const dy = troop.y - y;
                    const distanceSq = dx * dx + dy * dy;
                    if (distanceSq < radiusSq) {
                         troop.hp -= card.dmg; 
                         showDamageText(troop, card.dmg); // Show damage text
                    }
                }
            });

            Object.values(TOWERS).forEach(tower => {
                if (tower.side === 'opponent' && tower.hp > 0) {
                    const dx = tower.x - x;
                    const dy = tower.y - y;
                    const distanceSq = dx * dx + dy * dy;

                    if (distanceSq < radiusSq) {
                         tower.hp -= card.dmg;
                         updateHealthBar(tower, tower.hp, tower.maxHp);
                         showDamageText(tower, card.dmg); // Show damage text
                    }
                }
            });
             
            // Show simple flash effect
            const spellEffect = document.createElement('div');
            spellEffect.textContent = card.emoji;
            spellEffect.style.position = 'absolute';
            spellEffect.style.left = `${x - 25}px`;
            spellEffect.style.top = `${y - 25}px`;
            spellEffect.style.fontSize = '60px';
            spellEffect.style.opacity = 1;
            spellEffect.style.transition = 'opacity 0.3s ease-out';
            arena.appendChild(spellEffect);
            setTimeout(() => { spellEffect.style.opacity = 0; }, 100);
            setTimeout(() => { spellEffect.remove(); }, 400);
        }


        // --- 7. MAIN GAME LOOP ---

        function gameLoop() {
            activeTroops.forEach(troop => {
                if (troop.hp <= 0) return; 

                // 1. Target Priority: Enemy Unit in Range
                // If current target is dead or missing, find a new one
                if (!troop.target || troop.target.hp <= 0) {
                    troop.target = findClosestTarget(troop);
                }

                if (troop.target && troop.target.hp > 0) {
                    // Attack or Move towards Troop Target
                    const dx = troop.target.x - troop.x;
                    const dy = troop.target.y - troop.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= troop.range) {
                        troop.isAttacking = true;
                        if (troop.attackCooldown <= 0) {
                            troop.target.hp -= troop.dmg;
                            troop.attackCooldown = troop.attackSpeed; 
                            
                            updateHealthBar(troop.target, troop.target.hp, troop.target.maxHp);
                            showDamageText(troop.target, troop.dmg); // Show damage text
                        }
                    } else {
                        // Move straight toward the enemy troop/tower target
                        troop.isAttacking = false;
                        const ratio = troop.speed / distance;
                        troop.x += dx * ratio;
                        troop.y += dy * ratio;
                    }
                } else {
                    // 2. Pathfinding: Move toward Waypoint or Tower
                    
                    let destination = troop.currentDestination;
                    const targetTowerId = troop.side === 'player' ? 'O-L' : 'P-L'; 
                    const targetTower = TOWERS[targetTowerId];

                    if (targetTower && targetTower.hp > 0) {
                        // If troop reached its waypoint, set the Tower as the new destination
                        if (destination && Math.sqrt((destination.x - troop.x)**2 + (destination.y - troop.y)**2) < 10) {
                            troop.currentDestination = targetTower;
                            destination = targetTower;
                        } else if (!destination) {
                            // If no waypoint was set (e.g., troop was placed directly on bridge), move to tower
                            destination = targetTower;
                        }
                    } else {
                        // Fallback if the default tower is destroyed, use the King Tower
                        destination = troop.side === 'player' ? TOWERS['O-K'] : TOWERS['P-K'];
                    }


                    if (destination) {
                        const dx = destination.x - troop.x;
                        const dy = destination.y - troop.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > 5) { 
                            const ratio = troop.speed / distance;
                            troop.x += dx * ratio;
                            troop.y += dy * ratio;
                        }
                    }
                }

                // 3. Update Cooldown & Visuals
                if (troop.attackCooldown > 0) {
                    troop.attackCooldown--;
                }
                troop.element.style.left = `${troop.x - TROOP_SIZE_HALF}px`;
                troop.element.style.top = `${troop.y - TROOP_SIZE_HALF}px`;
                updateHealthBar(troop, troop.hp, troop.maxHp);
            });

            // --- 7.2 Cleanup Dead Units/Towers ---
            activeTroops = activeTroops.filter(troop => {
                if (troop.hp <= 0) {
                    troop.element.remove();
                    return false;
                }
                return true;
            });
            
            // Check Tower HP
            Object.keys(TOWERS).forEach(id => {
                 const tower = TOWERS[id];
                 if (tower.hp <= 0 && tower.element.textContent !== 'üí•') {
                    tower.element.textContent = 'üí•';
                    tower.element.style.opacity = '0.4';
                    tower.element.querySelector('.health-bar').style.display = 'none';
                    tower.x = -1000; 
                    tower.y = -1000;
                 }
            });
        }

        // --- 8. INITIALIZATION ---

        function initTowers() {
            const arenaRect = arena.getBoundingClientRect();

            document.querySelectorAll('.tower, .king-tower').forEach(el => {
                const id = el.getAttribute('data-id');
                const maxHp = parseInt(el.getAttribute('data-max-hp'));
                const side = id.startsWith('P') ? 'player' : 'opponent';
                
                const elRect = el.getBoundingClientRect();
                const x = elRect.left + (elRect.width / 2) - arenaRect.left;
                const y = elRect.top + (elRect.height / 2) - arenaRect.top;

                const tower = {
                    id: id,
                    side: side,
                    element: el,
                    hp: maxHp,
                    maxHp: maxHp,
                    dmg: 0, 
                    range: 0, 
                    x: x,
                    y: y,
                    isTower: true,
                };
                TOWERS[id] = tower;
                updateHealthBar(tower, tower.hp, tower.maxHp);
            });
        }


        function opponentAiLoop() {
            setInterval(() => {
                const troopCards = CARD_DEFINITIONS.filter(c => c.type === 'troop').sort((a,b) => a.cost - b.cost);
                
                // AI chooses a lane based on which side tower is healthier
                let spawnX;
                if (TOWERS['P-L'].hp > TOWERS['P-R'].hp) {
                    spawnX = 400; // Attack the weaker right tower (right lane)
                } else {
                    spawnX = 200; // Attack the left tower (left lane)
                }

                const spawnY = arena.offsetHeight * 0.2; 

                if (troopCards.length > 0) {
                    const cardToPlay = troopCards[0]; 

                    if (Math.random() > 0.2) { 
                        createTroop('opponent', cardToPlay, spawnX, spawnY);
                    }
                }
            }, 3000); 
        }

        function elixirLoop() {
            setInterval(() => {
                if (playerElixir < 10) {
                    playerElixir = Math.min(10, playerElixir + 1);
                    updateElixirUI();
                }
            }, 1000); 
        }

        function initGame() {
            initTowers();
            
            for(let i = 0; i < HAND_SIZE; i++) {
                drawCard();
            }

            setInterval(gameLoop, GAME_TICK_RATE); 
            elixirLoop();
            opponentAiLoop(); 
            
            console.log("Clash Clone Initialized! Pathfinding and damage numbers are active.");
        }


        window.onload = initGame;
    </script>
</body>
</html>
