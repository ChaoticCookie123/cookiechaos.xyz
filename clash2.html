<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clash Royale JS Clone - Combat Fixed</title>
    
    <style>
        /* --- CSS STYLES --- */
        :root {
            --arena-color: #38761D; 
            --river-color: #4A86E8; 
            --hand-bg-color: #333;
            --card-color: #8E7CC3; 
        }

        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #222;
        }

        #game-container {
            width: 600px; 
            height: 900px; 
            border: 5px solid #000;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        /* --- ARENA --- */

        #arena {
            flex-grow: 1;
            background-color: var(--arena-color);
            position: relative;
            border-top: 5px solid var(--river-color);
            border-bottom: 5px solid var(--river-color);
            cursor: default;
        }
        #arena.placing {
            cursor: crosshair; 
        }

        .side {
            height: 100px; 
            background-color: var(--arena-color);
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 0 10px;
        }

        .tower, .king-tower {
            font-size: 30px; 
            width: 80px;
            height: 80px;
            background-color: #ccc;
            border: 3px solid #000;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: default;
            position: relative;
        }

        .health-bar {
            position: absolute;
            top: 5px;
            width: 70px;
            height: 5px;
            background-color: red;
            border: 1px solid #000;
        }
        .health-fill {
            height: 100%;
            background-color: green;
            transition: width 0.1s; /* Faster transition for responsive damage */
        }

        /* River and Bridges */
        #arena::before {
            content: '';
            position: absolute;
            top: calc(50% - 5px); 
            left: 0;
            right: 0;
            height: 10px;
            background-color: var(--river-color);
            z-index: 1;
        }

        .bridge {
            position: absolute;
            width: 40px;
            height: 10px;
            background-color: #996633; 
            z-index: 2;
            top: calc(50% - 5px);
        }
        #bridge-1 { left: 150px; }
        #bridge-2 { right: 150px; }

        /* --- UI --- */

        #game-ui {
            height: 120px;
            background-color: var(--hand-bg-color);
            display: flex;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
            border-top: 5px solid #000;
        }

        #elixir-bar {
            background-color: #FFC000; 
            color: #000;
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 20px;
            width: 80px;
            text-align: center;
            margin-right: 20px;
        }

        #card-hand {
            display: flex;
            gap: 10px;
        }

        .card {
            width: 80px;
            height: 100px;
            background-color: var(--card-color);
            border: 4px solid #fff;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            align-items: center;
            cursor: pointer;
            transition: transform 0.1s;
            font-family: sans-serif;
            user-select: none;
            position: relative; 
            z-index: 50; 
        }

        .card.active-to-place {
            border-color: yellow;
            box-shadow: 0 0 10px yellow;
        }
        
        .card.disabled {
            filter: grayscale(100%);
            opacity: 0.5;
            cursor: default;
        }

        .card-emoji {
            font-size: 36px;
        }

        .card-cost {
            background-color: blue;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 14px;
            line-height: 20px;
            text-align: center;
            position: absolute;
            top: -10px;
            right: -10px;
            border: 2px solid #fff;
        }

        /* Troop Styling */
        .troop {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            z-index: 10;
        }
        .player-troop { background-color: #008000; border: 2px solid #000; }
        .opponent-troop { background-color: #FF0000; border: 2px solid #000; }
        .troop-health {
            position: absolute;
            bottom: -5px;
            width: 20px;
            height: 3px;
            background-color: red;
        }
        .troop-health-fill {
            height: 100%;
            background-color: limegreen;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="opponent-side" class="side">
            <div id="opponent-left-tower" class="tower" data-id="O-L" data-max-hp="1000">üè∞<div class="health-bar"><div class="health-fill"></div></div></div>
            <div id="opponent-king-tower" class="king-tower" data-id="O-K" data-max-hp="1500">üëë<div class="health-bar"><div class="health-fill"></div></div></div>
            <div id="opponent-right-tower" class="tower" data-id="O-R" data-max-hp="1000">üè∞<div class="health-bar"><div class="health-fill"></div></div></div>
        </div>

        <div id="arena">
            <div id="bridge-1" class="bridge"></div>
            <div id="bridge-2" class="bridge"></div>
        </div>

        <div id="player-side" class="side">
            <div id="player-left-tower" class="tower" data-id="P-L" data-max-hp="1000">üè∞<div class="health-bar"><div class="health-fill"></div></div></div>
            <div id="player-king-tower" class="king-tower" data-id="P-K" data-max-hp="1500">üëë<div class="health-bar"><div class="health-fill"></div></div></div>
            <div id="player-right-tower" class="tower" data-id="P-R" data-max-hp="1000">üè∞<div class="health-bar"><div class="health-fill"></div></div></div>
        </div>

        <div id="game-ui">
            <div id="elixir-bar">
                <span id="elixir-count">0</span> / 10
            </div>
            <div id="card-hand">
                </div>
        </div>
    </div>

    <script>
        // --- JAVASCRIPT LOGIC ---

        // --- 1. GAME CONSTANTS AND DATA ---
        const CARD_DEFINITIONS = [
            { name: "Knight", cost: 3, emoji: "üõ°Ô∏è", type: "troop", hp: 600, dmg: 50, range: 40, attackSpeed: 10 },
            { name: "Archers", cost: 3, emoji: "üèπ", type: "troop", hp: 300, dmg: 40, range: 200, attackSpeed: 15 },
            { name: "Giant", cost: 5, emoji: "üóø", type: "troop", hp: 1200, dmg: 70, range: 40, attackSpeed: 12 },
            { name: "Fireball", cost: 4, emoji: "üî•", type: "spell", dmg: 300 },
        ];

        const HAND_SIZE = 4;
        const GAME_TICK_RATE = 50; // 50ms per tick (20 FPS) - CRUCIAL FOR PERFORMANCE
        const TROOP_MOVEMENT_SPEED = 1.5; // Pixels per tick

        let playerElixir = 5;
        let playerHand = [];
        let cardToPlaceIndex = -1; 
        let activeTroops = []; 
        const TOWERS = {}; 

        // --- 2. DOM ELEMENTS ---
        const arena = document.getElementById('arena');
        const cardHandDiv = document.getElementById('card-hand');
        const elixirCountSpan = document.getElementById('elixir-count');

        // --- 3. CORE UTILITIES ---

        /** Updates the visual health bar for any game object (Tower or Troop). */
        function updateHealthBar(gameObject, currentHP, maxHP) {
            const percentage = (currentHP / maxHP) * 100;
            const fillElement = gameObject.element.querySelector(gameObject.isTower ? '.health-fill' : '.troop-health-fill');
            if (fillElement) {
                fillElement.style.width = `${Math.max(0, percentage)}%`;
            }
        }
        
        /** Finds the closest enemy object (Troop or Tower) within a given range. */
        function findClosestTarget(sourceTroop) {
            const enemySide = sourceTroop.side === 'player' ? 'opponent' : 'player';
            const targets = activeTroops.filter(t => t.side === enemySide && t.hp > 0);
            
            // Add alive towers to targets list
            Object.values(TOWERS).forEach(tower => {
                if (tower.side === enemySide && tower.hp > 0) {
                    targets.push(tower);
                }
            });

            let closestTarget = null;
            let minDistanceSq = Infinity;
            const rangeSq = sourceTroop.range * sourceTroop.range;

            targets.forEach(target => {
                const dx = target.x - sourceTroop.x;
                const dy = target.y - sourceTroop.y;
                const distanceSq = dx * dx + dy * dy;

                if (distanceSq < minDistanceSq) { // Find closest, regardless of range first
                    minDistanceSq = distanceSq;
                    closestTarget = target;
                }
            });
            
            // Only return the target if it is within attack range
            if (minDistanceSq <= rangeSq) {
                 return closestTarget;
            }
            return null; // Return null if closest enemy is out of range
        }


        // --- 4. CARD HAND AND UI ---
        
        function drawCard() {
            if (playerHand.length >= HAND_SIZE) return;
            const randomIndex = Math.floor(Math.random() * CARD_DEFINITIONS.length);
            const newCard = { ...CARD_DEFINITIONS[randomIndex] }; 
            playerHand.push(newCard);
            renderHand();
        }

        function updateElixirUI() {
            elixirCountSpan.textContent = playerElixir;
            
            document.querySelectorAll('.card').forEach(cardElement => {
                const index = parseInt(cardElement.getAttribute('data-card-index'));
                const cost = playerHand[index]?.cost || 99;
                
                if (playerElixir < cost) {
                    cardElement.classList.add('disabled');
                } else {
                    cardElement.classList.remove('disabled');
                }
            });
        }

        function renderHand() {
            cardHandDiv.innerHTML = '';
            playerHand.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.className = 'card';
                cardElement.setAttribute('data-card-index', index);
                cardElement.innerHTML = `
                    <span class="card-emoji">${card.emoji}</span>
                    <div class="card-cost">${card.cost}</div>
                `;
                
                cardElement.addEventListener('click', () => handleCardSelection(index));
                cardHandDiv.appendChild(cardElement);
            });
            updateElixirUI();
        }

        // --- 5. CLICK AND PLACE LOGIC ---

        function handleCardSelection(index) {
            const card = playerHand[index];
            if (playerElixir < card.cost) {
                return;
            }

            // Remove previous active state
            document.querySelectorAll('.card').forEach(c => c.classList.remove('active-to-place'));
            
            // Set new active state
            cardToPlaceIndex = index;
            const cardElement = document.querySelector(`.card[data-card-index="${index}"]`);
            cardElement.classList.add('active-to-place');
            arena.classList.add('placing');
        }

        arena.addEventListener('click', (e) => {
            if (cardToPlaceIndex === -1) return; 

            const rect = arena.getBoundingClientRect();
            // X and Y coordinates relative to the arena (0,0 is top-left of arena)
            const arenaX = e.clientX - rect.left;
            const arenaY = e.clientY - rect.top;
            
            // --- Deployment Zone Check (Bottom Half) ---
            const deploymentYThreshold = rect.height * 0.5; 

            if (arenaY < deploymentYThreshold) {
                // Not a fatal error, just stop placement
                return; 
            }
            
            handleCardPlacement(cardToPlaceIndex, arenaX, arenaY);
            
            // Reset placement state
            cardToPlaceIndex = -1;
            document.querySelectorAll('.card').forEach(c => c.classList.remove('active-to-place'));
            arena.classList.remove('placing');
        });

        function handleCardPlacement(cardIndex, x, y) {
            const card = playerHand[cardIndex];
            
            playerElixir -= card.cost;
            playerHand.splice(cardIndex, 1); 
            drawCard(); 
            updateElixirUI();
            
            if (card.type === 'troop') {
                createTroop('player', card, x, y); 
            } else if (card.type === 'spell') {
                applySpellEffect(card, x, y);
            }
        }

        // --- 6. TROOP & COMBAT LOGIC ---

        /** Creates a new troop object and its DOM element. */
        function createTroop(side, card, x, y) {
            const troopElement = document.createElement('div');
            troopElement.className = `troop ${side}-troop`;
            troopElement.textContent = card.emoji;
            troopElement.style.left = `${x - 15}px`;
            troopElement.style.top = `${y - 15}px`;
            
            // Add health bar
            troopElement.innerHTML += '<div class="troop-health"><div class="troop-health-fill" style="width:100%"></div></div>';
            
            arena.appendChild(troopElement);

            const newTroop = {
                id: Math.random(),
                side: side,
                element: troopElement,
                x: x, // Center X
                y: y, // Center Y
                hp: card.hp,
                maxHp: card.hp,
                dmg: card.dmg,
                range: card.range,
                speed: TROOP_MOVEMENT_SPEED, 
                target: null, 
                isAttacking: false,
                attackCooldown: 0,
                attackSpeed: card.attackSpeed, // Ticks between attacks
                isTower: false,
            };
            
            activeTroops.push(newTroop);
        }

        function applySpellEffect(card, x, y) {
             const spellRadius = 150; 
             const radiusSq = spellRadius * spellRadius;

            // Damage enemy troops
            activeTroops.forEach(troop => {
                if (troop.side === 'opponent') {
                    const dx = troop.x - x;
                    const dy = troop.y - y;
                    const distanceSq = dx * dx + dy * dy;
                    if (distanceSq < radiusSq) {
                         troop.hp -= card.dmg; 
                    }
                }
            });

            // Damage enemy towers 
            Object.values(TOWERS).forEach(tower => {
                if (tower.side === 'opponent' && tower.hp > 0) {
                    const dx = tower.x - x;
                    const dy = tower.y - y;
                    const distanceSq = dx * dx + dy * dy;

                    if (distanceSq < radiusSq) {
                         tower.hp -= card.dmg;
                         updateHealthBar(tower, tower.hp, tower.maxHp);
                    }
                }
            });
             
            // Show simple flash effect
            const spellEffect = document.createElement('div');
            spellEffect.textContent = card.emoji;
            spellEffect.style.position = 'absolute';
            spellEffect.style.left = `${x - 25}px`;
            spellEffect.style.top = `${y - 25}px`;
            spellEffect.style.fontSize = '60px';
            spellEffect.style.opacity = 1;
            spellEffect.style.transition = 'opacity 0.3s ease-out';
            arena.appendChild(spellEffect);
            setTimeout(() => { spellEffect.style.opacity = 0; }, 100);
            setTimeout(() => { spellEffect.remove(); }, 400);
        }


        // --- 7. MAIN GAME LOOP ---

        function gameLoop() {
            // --- 7.1 Troop Logic (Movement and Targeting) ---
            activeTroops.forEach(troop => {
                if (troop.hp <= 0) return; 

                // 1. Find Target
                // If current target is dead or missing, find a new one
                if (!troop.target || troop.target.hp <= 0) {
                    troop.target = findClosestTarget(troop);
                }

                if (troop.target && troop.target.hp > 0) {
                    // Calculate distance to target
                    const dx = troop.target.x - troop.x;
                    const dy = troop.target.y - troop.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // 2. Attack or Move
                    if (distance <= troop.range) {
                        // Attack
                        troop.isAttacking = true;
                        if (troop.attackCooldown <= 0) {
                            troop.target.hp -= troop.dmg;
                            troop.attackCooldown = troop.attackSpeed; 
                            
                            // Update target health bar
                            updateHealthBar(troop.target, troop.target.hp, troop.target.maxHp);
                        }
                    } else {
                        // Move
                        troop.isAttacking = false;
                        const ratio = troop.speed / distance;
                        troop.x += dx * ratio;
                        troop.y += dy * ratio;
                    }
                } else {
                    // No Target found, move towards the opponent's closest tower (simplified path)
                    const targetTowerId = troop.side === 'player' ? 'O-L' : 'P-L'; // Always target left tower first
                    const targetTower = TOWERS[targetTowerId];

                    if (targetTower && targetTower.hp > 0) {
                        const dx = targetTower.x - troop.x;
                        const dy = targetTower.y - troop.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > 5) { // Keep moving until very close
                            const ratio = troop.speed / distance;
                            troop.x += dx * ratio;
                            troop.y += dy * ratio;
                        }
                    }
                }

                // 3. Update Cooldown & Visuals
                if (troop.attackCooldown > 0) {
                    troop.attackCooldown--;
                }
                troop.element.style.left = `${troop.x - 15}px`;
                troop.element.style.top = `${troop.y - 15}px`;
                updateHealthBar(troop, troop.hp, troop.maxHp);
            });

            // --- 7.2 Cleanup Dead Units/Towers ---
            activeTroops = activeTroops.filter(troop => {
                if (troop.hp <= 0) {
                    troop.element.remove();
                    return false;
                }
                return true;
            });
            
            // Check Tower HP
            Object.keys(TOWERS).forEach(id => {
                 const tower = TOWERS[id];
                 if (tower.hp <= 0 && tower.element.textContent !== 'üí•') {
                    // Visually mark as destroyed
                    tower.element.textContent = 'üí•';
                    tower.element.style.opacity = '0.4';
                    tower.element.querySelector('.health-bar').style.display = 'none';
                    // Re-calculate tower coordinates on the map after tower is gone.
                    tower.x = -1000; 
                    tower.y = -1000;
                 }
            });
        }

        // --- 8. INITIALIZATION ---

        function initTowers() {
            const arenaRect = arena.getBoundingClientRect();

            document.querySelectorAll('.tower, .king-tower').forEach(el => {
                const id = el.getAttribute('data-id');
                const maxHp = parseInt(el.getAttribute('data-max-hp'));
                const side = id.startsWith('P') ? 'player' : 'opponent';
                
                // Get tower center coordinates relative to the arena
                const elRect = el.getBoundingClientRect();
                const x = elRect.left + (elRect.width / 2) - arenaRect.left;
                const y = elRect.top + (elRect.height / 2) - arenaRect.top;

                const tower = {
                    id: id,
                    side: side,
                    element: el,
                    hp: maxHp,
                    maxHp: maxHp,
                    dmg: 0, 
                    range: 0, 
                    x: x,
                    y: y,
                    isTower: true,
                };
                TOWERS[id] = tower;
                updateHealthBar(tower, tower.hp, tower.maxHp);
            });
        }


        /** Simple Opponent AI (Spawns consistently) */
        function opponentAiLoop() {
            setInterval(() => {
                // Find only the cheapest troop card to ensure easy deployment
                const troopCards = CARD_DEFINITIONS.filter(c => c.type === 'troop').sort((a,b) => a.cost - b.cost);
                
                // Prioritize lanes where towers are still standing
                const targetLane = (TOWERS['P-L'].hp > 0) ? 200 : 400; // Left lane X or Right lane X
                const spawnX = targetLane;
                const spawnY = arena.offsetHeight * 0.2; // Opponent's territory

                if (troopCards.length > 0) {
                    const cardToPlay = troopCards[0]; // Always play the cheapest one

                    // 80% chance to "afford" and play the card every 3 seconds
                    if (Math.random() > 0.2) { 
                        createTroop('opponent', cardToPlay, spawnX, spawnY);
                    }
                }
            }, 3000); 
        }

        function initGame() {
            initTowers();
            
            for(let i = 0; i < HAND_SIZE; i++) {
                drawCard();
            }

            setInterval(gameLoop, GAME_TICK_RATE); // Start the main game loop (20 times per second)
            elixirLoop();
            opponentAiLoop(); 
            
            console.log("Clash Clone Initialized! Performance and Combat should now be stable.");
        }

        // Elixir generation loop (from previous version)
        function elixirLoop() {
            setInterval(() => {
                if (playerElixir < 10) {
                    playerElixir = Math.min(10, playerElixir + 1);
                    updateElixirUI();
                }
            }, 1000); 
        }


        window.onload = initGame;
    </script>
</body>
</html>
