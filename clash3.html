<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Clash Lite</title>
    <style>
        body {
            background-color: #222; margin: 0; overflow: hidden;
            display: flex; justify-content: center; align-items: center;
            font-family: sans-serif; user-select: none;
        }
        #game-container {
            position: relative; width: 400px; height: 700px;
            background: #333; border: 4px solid #555;
            box-shadow: 0 0 20px black;
        }
        canvas { display: block; width: 100%; height: 100%; }
        
        /* UI */
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        #elixir-bar {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 120px;
            background: #222; border-top: 4px solid #444; pointer-events: auto;
            display: flex; justify-content: center; align-items: center; gap: 10px;
        }
        
        #elixir-display {
            position: absolute; bottom: 125px; left: 10px;
            color: #d0f; font-weight: bold; font-size: 24px;
            text-shadow: 2px 2px 0 #000;
        }

        .card {
            width: 70px; height: 90px; background: #444; border: 2px solid #888;
            border-radius: 8px; display: flex; flex-direction: column; 
            align-items: center; justify-content: center; cursor: pointer;
        }
        .card.selected { border-color: gold; background: #555; transform: translateY(-10px); }
        .card.disabled { opacity: 0.5; filter: grayscale(1); }
        .cost { color: #d0f; font-weight: bold; margin-bottom: 5px; }
        .icon { font-size: 30px; }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="cvs" width="400" height="700"></canvas>
    
    <div id="ui">
        <div id="elixir-display">5 Elixir</div>
        <div id="elixir-bar">
            </div>
    </div>
</div>

<script>
    const cvs = document.getElementById('cvs');
    const ctx = cvs.getContext('2d');
    
    // Config
    const W = 400, H = 700;
    const RIVER_Y = 320;
    const BRIDGE_L = 90, BRIDGE_R = 310;
    
    // State
    let elixir = 5;
    let entities = [];
    let projectiles = [];
    let lastTime = 0;
    let spawnTimer = 3.0;
    let selectedType = 'knight';

    const CARDS = {
        'knight': { cost: 3, hp: 800, dmg: 80, speed: 60, range: 30, icon: '‚öîÔ∏è', color: '#4facfe', type: 'ground' },
        'archer': { cost: 3, hp: 300, dmg: 60, speed: 70, range: 120, icon: 'üèπ', color: '#d57eeb', type: 'ground' },
        'giant':  { cost: 5, hp: 2500, dmg: 150, speed: 35, range: 30, icon: 'üëπ', color: '#fa709a', type: 'building' },
        'hog':    { cost: 4, hp: 1000, dmg: 180, speed: 100, range: 30, icon: 'üî®', color: '#f6d365', type: 'building' }
    };

    function init() {
        // Build UI
        const bar = document.getElementById('elixir-bar');
        for(let k in CARDS) {
            let c = CARDS[k];
            let div = document.createElement('div');
            div.className = 'card ' + (k==='knight'?'selected':'');
            div.id = 'card-'+k;
            div.innerHTML = `<span class="cost">${c.cost}</span><span class="icon">${c.icon}</span>`;
            div.onclick = () => {
                selectedType = k;
                document.querySelectorAll('.card').forEach(e => e.classList.remove('selected'));
                div.classList.add('selected');
            };
            bar.appendChild(div);
        }

        // Add Towers
        // Player
        addEntity(new Entity(90, 550, true, 'tower'));
        addEntity(new Entity(310, 550, true, 'tower'));
        addEntity(new Entity(200, 620, true, 'king'));
        // Enemy
        addEntity(new Entity(90, 100, false, 'tower'));
        addEntity(new Entity(310, 100, false, 'tower'));
        addEntity(new Entity(200, 40, false, 'king'));

        requestAnimationFrame(loop);
    }

    // --- INPUT ---
    cvs.addEventListener('pointerdown', e => {
        const rect = cvs.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (W / rect.width);
        const y = (e.clientY - rect.top) * (H / rect.height);

        // Logic
        if (y < RIVER_Y) return; // Can't place on enemy side
        
        const card = CARDS[selectedType];
        if (elixir >= card.cost) {
            elixir -= card.cost;
            addEntity(new Entity(x, y, true, 'unit', card));
        }
    });

    function addEntity(ent) {
        entities.push(ent);
        // Sort so towers draw first (bottom), units on top
        entities.sort((a,b) => (a.y - b.y)); 
    }

    // --- CLASSES ---
    class Entity {
        constructor(x, y, isPlayer, role, stats) {
            this.x = x; 
            this.y = y; 
            this.isPlayer = isPlayer;
            this.role = role; // 'tower', 'king', 'unit'
            
            if (role === 'unit') {
                this.hp = stats.hp; this.maxHp = stats.hp;
                this.dmg = stats.dmg; this.speed = stats.speed;
                this.range = stats.range; this.icon = stats.icon;
                this.targetType = stats.type; // 'ground' or 'building'
                this.radius = 15;
            } else {
                // Tower Stats
                this.hp = 2000; this.maxHp = 2000;
                this.dmg = 70; this.speed = 0; // TOWER SPEED MUST BE 0
                this.range = 150; this.icon = role==='king' ? 'üëë' : 'üè∞';
                this.targetType = 'any';
                this.radius = 30;
            }
            
            this.cooldown = 0;
            this.isDead = false;
        }

        update(dt) {
            if (this.cooldown > 0) this.cooldown -= dt;

            // 1. Find Target
            let target = null;
            let minDist = 9999;

            for(let e of entities) {
                if (e.isPlayer === this.isPlayer || e.isDead) continue;
                
                // Giant Logic: Ignore units, go for towers
                if (this.targetType === 'building' && e.role === 'unit') continue;

                let d = Math.hypot(e.x - this.x, e.y - this.y);
                if (d < minDist) {
                    minDist = d;
                    target = e;
                }
            }

            // 2. Action: Attack or Move
            if (target && minDist <= this.range + target.radius) {
                // ATTACK
                if (this.cooldown <= 0) {
                    projectiles.push({
                        x: this.x, y: this.y - 10,
                        tx: target.x, ty: target.y - 10,
                        dmg: this.dmg, speed: 300,
                        isPlayer: this.isPlayer
                    });
                    this.cooldown = 1.0;
                }
            } else if (this.speed > 0) { 
                // MOVE (Only if speed > 0, keeps towers static)
                let tx, ty;

                // Pathfinding logic
                if (target) {
                    tx = target.x; ty = target.y;
                } else {
                    // Default: Go to Enemy King
                    tx = 200; ty = this.isPlayer ? 40 : 620;
                }

                // Bridge Logic
                const isNorth = this.y < RIVER_Y;
                const wantNorth = ty < RIVER_Y;
                
                // If crossing the river...
                if (isNorth !== wantNorth) {
                    // Pick nearest bridge
                    const distL = Math.abs(this.x - BRIDGE_L);
                    const distR = Math.abs(this.x - BRIDGE_R);
                    const bridgeX = distL < distR ? BRIDGE_L : BRIDGE_R;

                    // If not aligned with bridge, walk to bridge X first
                    if (Math.abs(this.x - bridgeX) > 10) {
                        tx = bridgeX;
                        ty = this.y; // Keep Y same (walk sideways)
                    } else {
                        // Aligned, cross bridge
                        tx = bridgeX;
                        ty = isNorth ? RIVER_Y + 50 : RIVER_Y - 50; 
                    }
                }

                // Move Math
                const angle = Math.atan2(ty - this.y, tx - this.x);
                this.x += Math.cos(angle) * this.speed * dt;
                this.y += Math.sin(angle) * this.speed * dt;
            }
        }

        draw() {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();

            // Icon
            ctx.font = this.role === 'unit' ? '24px Arial' : '40px Arial';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(this.icon, this.x, this.y);

            // HP Bar
            const pct = this.hp / this.maxHp;
            ctx.fillStyle = 'red'; ctx.fillRect(this.x-15, this.y-35, 30, 4);
            ctx.fillStyle = '#0f0'; ctx.fillRect(this.x-15, this.y-35, 30*pct, 4);
        }
    }

    // --- GAME LOOP ---
    function loop(now) {
        const dt = Math.min((now - lastTime) / 1000, 0.1);
        lastTime = now;

        // 1. Update Elixir
        if (elixir < 10) elixir += 0.5 * dt;
        document.getElementById('elixir-display').innerText = Math.floor(elixir);
        
        // 2. Grayscale UI
        for(let k in CARDS) {
            let el = document.getElementById('card-'+k);
            if(CARDS[k].cost > elixir) el.classList.add('disabled');
            else el.classList.remove('disabled');
        }

        // 3. Spawner AI
        spawnTimer -= dt;
        if (spawnTimer <= 0) {
            let lane = Math.random() > 0.5 ? BRIDGE_L : BRIDGE_R;
            // Enemy spawns random unit
            let keys = Object.keys(CARDS);
            let randCard = CARDS[keys[Math.floor(Math.random()*keys.length)]];
            
            addEntity(new Entity(lane, 20, false, 'unit', randCard));
            spawnTimer = 4.0;
        }

        // 4. Update Entities
        for(let i = entities.length-1; i>=0; i--) {
            let e = entities[i];
            e.update(dt);
            if(e.hp <= 0) entities.splice(i, 1);
        }

        // 5. Update Projectiles
        for(let i = projectiles.length-1; i>=0; i--) {
            let p = projectiles[i];
            let dx = p.tx - p.x;
            let dy = p.ty - p.y;
            let d = Math.hypot(dx, dy);

            if (d < 10) {
                // Hit! Find closest enemy to impact
                let target = entities.find(e => e.isPlayer !== p.isPlayer && Math.hypot(e.x - p.x, e.y - p.y) < 30);
                if(target) target.hp -= p.dmg;
                projectiles.splice(i, 1);
            } else {
                p.x += (dx/d) * p.speed * dt;
                p.y += (dy/d) * p.speed * dt;
            }
        }

        draw();
        requestAnimationFrame(loop);
    }

    function draw() {
        // Map
        ctx.fillStyle = '#3b8c3b'; ctx.fillRect(0,0,W,H); // Grass
        ctx.fillStyle = '#4fa3e3'; ctx.fillRect(0, RIVER_Y-20, W, 40); // River
        
        // Bridges
        ctx.fillStyle = '#8d6e63'; 
        ctx.fillRect(BRIDGE_L-20, RIVER_Y-22, 40, 44);
        ctx.fillRect(BRIDGE_R-20, RIVER_Y-22, 40, 44);

        // Spawn Line
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.setLineDash([10,10]);
        ctx.beginPath(); ctx.moveTo(0, RIVER_Y); ctx.lineTo(W, RIVER_Y); ctx.stroke();
        ctx.setLineDash([]);

        // Entities
        entities.forEach(e => e.draw());

        // Projectiles
        ctx.fillStyle = 'yellow';
        projectiles.forEach(p => {
            ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI*2); ctx.fill();
        });
    }

    init();

</script>
</body>
</html>
