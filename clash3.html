<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clash Clone - Free Placement</title>
    
    <style>
        /* --- General Styling --- */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; 
            margin: 0;
            background-color: #2c2c2c; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            flex-direction: column;
            color: white;
            user-select: none;
        }

        /* --- Game Container --- */
        #game-container {
            border: 12px solid #5a3e2a; 
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            overflow: hidden; 
            background-color: #3b8c3b; /* Grass base */
        }

        #gameCanvas {
            display: block;
            cursor: crosshair;
        }

        /* --- UI Overlay --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #elixir-bar-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 25px;
            background: rgba(0,0,0,0.6);
            border: 2px solid #a3a3a3;
            border-radius: 12px;
            overflow: hidden;
        }

        #elixir-fill {
            height: 100%;
            background: linear-gradient(90deg, #d336d3, #ff6bff);
            width: 0%; /* Updated by JS */
            transition: width 0.1s linear;
        }

        #elixir-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            font-size: 14px;
        }

        .message {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }

        #card-selection {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }

        .card {
            width: 60px;
            height: 80px;
            background: #444;
            border: 3px solid #888;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.1s;
        }
        
        .card.selected {
            border-color: #ffd700;
            transform: scale(1.1);
            background: #555;
        }

        .card-cost {
            font-size: 12px;
            color: #d336d3;
            font-weight: bold;
            margin-top: 5px;
        }
        
        .card-icon {
            font-size: 24px;
        }

    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="480" height="720"></canvas>
        
        <div id="ui-layer">
            <div class="message" id="message-display">Not Enough Elixir!</div>
            
            <div id="card-selection">
                <div class="card selected" onclick="selectCard('tower')">
                    <span class="card-icon">üè∞</span>
                    <span class="card-cost">4</span>
                </div>
            </div>

            <div id="elixir-bar-container">
                <div id="elixir-fill"></div>
                <span id="elixir-text">0 / 10</span>
            </div>
        </div>
    </div>

    <div style="margin-top: 15px; text-align: center; color: #aaa; font-size: 0.9em;">
        Click anywhere on your side (bottom half) to place a Tower.<br>
        Enemies will spawn from the top. Defend your territory!
    </div>

    <script>
        // --- Configuration ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const CANVAS_WIDTH = canvas.width;
        const CANVAS_HEIGHT = canvas.height;
        const RIVER_Y = CANVAS_HEIGHT / 2;
        
        // Game Constants
        const ELIXIR_MAX = 10;
        const ELIXIR_REGEN_RATE = 0.5; // per second
        const TOWER_COST = 4;
        const SPAWN_RATE_INITIAL = 3.0; // Seconds between enemies
        
        // Game State
        let lastTime = 0;
        let elixir = 5;
        let spawnTimer = 0;
        let gameObjects = [];
        let score = 0;
        
        // --- Input Handling ---
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            handleInput(x, y);
        });

        function handleInput(x, y) {
            // Check if click is on player side (bottom half)
            if (y > RIVER_Y) {
                if (elixir >= TOWER_COST) {
                    // Place Tower
                    gameObjects.push(new Tower(x, y, true)); // true = isPlayer
                    elixir -= TOWER_COST;
                    spawnEffect(x, y, 'place');
                } else {
                    showMessage("Not enough Elixir!");
                }
            } else {
                showMessage("Can only place on your side!");
            }
        }

        // --- Classes ---

        class GameObject {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.isDead = false;
            }
            update(dt) {}
            draw() {}
        }

        class Unit extends GameObject {
            constructor(x, y, isPlayer, type = 'basic') {
                super(x, y);
                this.isPlayer = isPlayer;
                this.type = type;
                
                // Stats
                this.hp = 100;
                this.maxHp = 100;
                this.speed = 40; // pixels per second
                this.radius = 12;
                this.damage = 10;
                this.attackRange = 40;
                this.attackCooldown = 1.0;
                this.currentCooldown = 0;
                
                // Visuals
                this.color = isPlayer ? '#4a90e2' : '#e74c3c';
            }

            update(dt) {
                if (this.currentCooldown > 0) this.currentCooldown -= dt;

                // Simple AI: Move towards closest enemy or enemy base edge
                let target = this.findTarget();
                
                if (target) {
                    const dx = target.x - this.x;
                    const dy = target.y - this.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    if (dist <= this.attackRange) {
                        // Attack
                        if (this.currentCooldown <= 0) {
                            this.attack(target);
                            this.currentCooldown = this.attackCooldown;
                        }
                    } else {
                        // Move
                        this.x += (dx / dist) * this.speed * dt;
                        this.y += (dy / dist) * this.speed * dt;
                    }
                } else {
                    // No specific target, move forward
                    // Enemy moves DOWN (+y), Player moves UP (-y)
                    const moveDir = this.isPlayer ? -1 : 1;
                    this.y += this.speed * moveDir * dt;
                }

                // Bounds check (despawn if off screen)
                if (this.y < -50 || this.y > CANVAS_HEIGHT + 50) {
                    this.isDead = true;
                }
            }

            findTarget() {
                // Find closest enemy unit or tower
                let closest = null;
                let closestDist = Infinity;

                for (const obj of gameObjects) {
                    if (obj instanceof Unit || obj instanceof Tower) {
                        if (obj.isPlayer !== this.isPlayer && !obj.isDead) {
                            const dx = obj.x - this.x;
                            const dy = obj.y - this.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            
                            // Aggro range check (simple global aggro for now)
                            if (dist < 200 && dist < closestDist) {
                                closestDist = dist;
                                closest = obj;
                            }
                        }
                    }
                }
                return closest;
            }

            attack(target) {
                gameObjects.push(new Projectile(this.x, this.y, target, this.damage));
            }

            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) {
                    this.isDead = true;
                    spawnEffect(this.x, this.y, 'death');
                    if (!this.isPlayer) score += 10;
                }
            }

            draw() {
                // Health Bar
                const hpPercent = this.hp / this.maxHp;
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x - 10, this.y - 20, 20, 4);
                ctx.fillStyle = '#0f0';
                ctx.fillRect(this.x - 10, this.y - 20, 20 * hpPercent, 4);

                // Body
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        class Tower extends GameObject {
            constructor(x, y, isPlayer) {
                super(x, y);
                this.isPlayer = isPlayer;
                this.hp = 400;
                this.maxHp = 400;
                this.range = 150;
                this.damage = 25;
                this.attackCooldown = 0.8;
                this.currentCooldown = 0;
                this.radius = 20;
            }

            update(dt) {
                if (this.currentCooldown > 0) this.currentCooldown -= dt;

                // Find enemy in range
                for (const obj of gameObjects) {
                    if (obj instanceof Unit && obj.isPlayer !== this.isPlayer && !obj.isDead) {
                        const dist = Math.hypot(obj.x - this.x, obj.y - this.y);
                        if (dist <= this.range) {
                            if (this.currentCooldown <= 0) {
                                this.fire(obj);
                                this.currentCooldown = this.attackCooldown;
                            }
                            return; // Attack one at a time
                        }
                    }
                }
            }

            fire(target) {
                gameObjects.push(new Projectile(this.x, this.y - 10, target, this.damage, true)); // true = isTowerShot
            }

            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) {
                    this.isDead = true;
                    spawnEffect(this.x, this.y, 'explosion');
                }
            }

            draw() {
                // Range Circle (subtle)
                /*
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.range, 0, Math.PI*2);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.stroke();
                */

                // Health Bar
                const hpPercent = this.hp / this.maxHp;
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x - 15, this.y - 35, 30, 5);
                ctx.fillStyle = '#0f0';
                ctx.fillRect(this.x - 15, this.y - 35, 30 * hpPercent, 5);

                // Tower Base
                ctx.fillStyle = this.isPlayer ? '#2980b9' : '#c0392b';
                ctx.fillRect(this.x - 15, this.y - 15, 30, 30);
                
                // Turret
                ctx.fillStyle = '#eee';
                ctx.beginPath();
                ctx.arc(this.x, this.y - 5, 12, 0, Math.PI*2);
                ctx.fill();
                ctx.stroke();
            }
        }

        class Projectile extends GameObject {
            constructor(x, y, target, damage, isTowerShot = false) {
                super(x, y);
                this.target = target;
                this.damage = damage;
                this.speed = 250;
                this.isTowerShot = isTowerShot;
                this.hit = false;
            }

            update(dt) {
                if (this.hit) return;

                if (this.target.isDead) {
                    this.isDead = true;
                    return;
                }

                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < 10) {
                    this.target.takeDamage(this.damage);
                    this.hit = true;
                    this.isDead = true;
                    spawnEffect(this.target.x, this.target.y, 'hit');
                } else {
                    this.x += (dx / dist) * this.speed * dt;
                    this.y += (dy / dist) * this.speed * dt;
                }
            }

            draw() {
                ctx.fillStyle = this.isTowerShot ? '#f1c40f' : '#fff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI*2);
                ctx.fill();
            }
        }

        class Effect extends GameObject {
            constructor(x, y, type) {
                super(x, y);
                this.type = type;
                this.timer = 0;
                this.maxTime = 0.5;
            }

            update(dt) {
                this.timer += dt;
                if (this.timer >= this.maxTime) this.isDead = true;
            }

            draw() {
                const alpha = 1 - (this.timer / this.maxTime);
                ctx.globalAlpha = alpha;
                
                if (this.type === 'hit') {
                    ctx.fillStyle = 'orange';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 8, 0, Math.PI*2);
                    ctx.fill();
                } else if (this.type === 'death') {
                    ctx.fillStyle = '#555';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 15, 0, Math.PI*2);
                    ctx.fill();
                } else if (this.type === 'place') {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 25 * (this.timer * 4), 0, Math.PI*2);
                    ctx.stroke();
                } else if (this.type === 'explosion') {
                    ctx.fillStyle = 'orange';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 30 * (this.timer * 2), 0, Math.PI*2);
                    ctx.fill();
                }

                ctx.globalAlpha = 1.0;
            }
        }

        // --- Helpers ---

        function spawnEffect(x, y, type) {
            gameObjects.push(new Effect(x, y, type));
        }

        function showMessage(text) {
            const msg = document.getElementById('message-display');
            msg.textContent = text;
            msg.style.opacity = 1;
            setTimeout(() => {
                msg.style.opacity = 0;
            }, 1000);
        }

        function updateUI() {
            // Update Elixir Bar
            const fill = document.getElementById('elixir-fill');
            const text = document.getElementById('elixir-text');
            const pct = (elixir / ELIXIR_MAX) * 100;
            fill.style.width = `${pct}%`;
            text.textContent = `${Math.floor(elixir)} / ${ELIXIR_MAX}`;

            // Greyscale card if not enough elixir
            const card = document.querySelector('.card');
            if (elixir < TOWER_COST) {
                card.style.filter = 'grayscale(1)';
                card.style.opacity = '0.7';
            } else {
                card.style.filter = 'none';
                card.style.opacity = '1';
            }
        }

        function updateEnemySpawn(dt) {
            spawnTimer -= dt;
            if (spawnTimer <= 0) {
                // Spawn Enemy at random x at top
                const x = 50 + Math.random() * (CANVAS_WIDTH - 100);
                gameObjects.push(new Unit(x, -20, false)); // false = Enemy
                
                // Difficulty ramps up slightly
                spawnTimer = SPAWN_RATE_INITIAL - Math.min(2.0, score / 500);
                if (spawnTimer < 0.5) spawnTimer = 0.5;
            }
        }

        function drawBackground() {
            // Grass
            ctx.fillStyle = '#3b8c3b';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // River
            ctx.fillStyle = '#3498db';
            ctx.fillRect(0, RIVER_Y - 20, CANVAS_WIDTH, 40);

            // Bridges (Visual only, since we have free movement/placement for now)
            ctx.fillStyle = '#8e44ad'; // Magical bridge color or wood
            const bridgeWidth = 60;
            ctx.fillRect(80, RIVER_Y - 22, bridgeWidth, 44); // Left
            ctx.fillRect(CANVAS_WIDTH - 80 - bridgeWidth, RIVER_Y - 22, bridgeWidth, 44); // Right

            // Valid Zone Indicator (Subtle overlay on bottom half)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
            ctx.fillRect(0, RIVER_Y, CANVAS_WIDTH, CANVAS_HEIGHT / 2);
        }

        // --- Main Loop ---

        function initGame() {
            elixir = 5;
            gameObjects = [];
            score = 0;
            
            // Initial Enemy
            gameObjects.push(new Unit(CANVAS_WIDTH/2, -20, false));
        }

        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            // Logic
            if (elixir < ELIXIR_MAX) {
                elixir += ELIXIR_REGEN_RATE * deltaTime;
                if (elixir > ELIXIR_MAX) elixir = ELIXIR_MAX;
            }
            
            updateEnemySpawn(deltaTime);
            updateUI();

            // Draw Background
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            drawBackground();

            // Update & Draw Objects
            // Sort by Y so lower objects draw on top of higher ones (pseudo-3D depth)
            gameObjects.sort((a, b) => a.y - b.y);

            for (let i = gameObjects.length - 1; i >= 0; i--) {
                const obj = gameObjects[i];
                obj.update(deltaTime);
                obj.draw();
                
                if (obj.isDead) {
                    gameObjects.splice(i, 1);
                }
            }

            requestAnimationFrame(gameLoop);
        }

        // Start
        initGame();
        requestAnimationFrame(gameLoop);

    </script>
</body>
</html>
