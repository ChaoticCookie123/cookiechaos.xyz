<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">

    <title>Clash Clone - Fixed Input</title>
    
    <style>
        body {
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh; margin: 0; background-color: #1a1a1a; 
            font-family: 'Segoe UI', sans-serif; color: white; user-select: none; overflow: hidden;
            touch-action: none; /* Prevent scroll on mobile */
        }
        #game-wrapper { position: relative; }
        #game-container {
            border: 8px solid #4a3b2a; position: relative;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8); border-radius: 12px;
            overflow: hidden; background-color: #3b8c3b; cursor: crosshair;
        }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* Elixir */
        #elixir-bar-container {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            width: 90%; height: 25px; background: rgba(0,0,0,0.8);
            border: 2px solid #555; border-radius: 15px; overflow: hidden;
        }
        #elixir-fill { height: 100%; background: linear-gradient(90deg, #c0392b, #d336d3); width: 0%; transition: width 0.1s linear; }
        #elixir-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-weight: 800; text-shadow: 1px 1px 2px black; font-size: 14px; z-index: 2;
        }

        /* Card Selection */
        #card-selection {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 6px; pointer-events: auto;
            width: 95%; overflow-x: auto; padding-bottom: 5px;
            scrollbar-width: none; 
        }
        #card-selection::-webkit-scrollbar { display: none; }

        .card {
            min-width: 60px; height: 80px; background: #2c3e50;
            border: 3px solid #7f8c8d; border-radius: 8px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: transform 0.1s; position: relative;
        }
        .card:active { transform: scale(0.95); }
        .card.selected { border-color: #f1c40f; background: #34495e; transform: translateY(-8px); box-shadow: 0 0 10px #f1c40f; }
        .card-cost {
            position: absolute; top: -5px; left: -5px; background: #d336d3; width: 18px; height: 18px;
            border-radius: 50%; font-size: 11px; font-weight: bold;
            display: flex; align-items: center; justify-content: center; border: 2px solid white;
        }
        .card-icon { font-size: 22px; }
        .card-name { font-size: 8px; color: #ccc; margin-top: 4px; text-transform: uppercase; text-align: center; }

        /* Game Over */
        #game-over {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 10;
            opacity: 0; pointer-events: none; transition: opacity 0.5s;
        }
        #game-over h1 { font-size: 40px; margin: 0; color: #f1c40f; text-shadow: 0 0 10px red; }
        #restart-btn {
            margin-top: 20px; padding: 10px 20px; font-size: 18px;
            background: #3498db; color: white; border: none; border-radius: 5px;
            cursor: pointer; pointer-events: auto;
        }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div id="game-container">
        <canvas id="gameCanvas" width="450" height="700"></canvas>
        
        <div id="ui-layer">
            <div id="card-selection"></div>
            <div id="elixir-bar-container">
                <div id="elixir-fill"></div>
                <span id="elixir-text">5 / 10</span>
            </div>
            <div id="game-over">
                <h1 id="go-title">GAME OVER</h1>
                <button id="restart-btn" onclick="initGame()">Play Again</button>
            </div>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const CW = canvas.width; const CH = canvas.height;
    const RIVER_Y = CH / 2;
    const BRIDGE_LEFT_X = 100; const BRIDGE_RIGHT_X = CW - 100;

    const ELIXIR_MAX = 10;
    const ELIXIR_REGEN = 0.5;

    // --- CARD DATA ---
    const CARDS = {
        'knight': { name: 'Knight', icon: 'âš”ï¸', cost: 3, type: 'ground', count: 1, hp: 650, dmg: 75, speed: 45, range: 40, target: 'ground', color: '#3498db', radius: 14, hitAir: false },
        'archers': { name: 'Archers', icon: 'ðŸ¹', cost: 3, type: 'ground', count: 2, hp: 220, dmg: 45, speed: 50, range: 120, target: 'any', color: '#e056fd', radius: 12, hitAir: true },
        'giant': { name: 'Giant', icon: 'ðŸ‘¹', cost: 5, type: 'ground', count: 1, hp: 2000, dmg: 120, speed: 30, range: 40, target: 'building', color: '#e67e22', radius: 24, hitAir: false },
        'minions': { name: 'Minions', icon: 'ðŸ¦‡', cost: 3, type: 'air', count: 3, hp: 150, dmg: 40, speed: 70, range: 30, target: 'any', color: '#8e44ad', radius: 10, hitAir: true, flying: true },
        'hog': { name: 'Hog Rider', icon: 'ðŸ”¨', cost: 4, type: 'ground', count: 1, hp: 800, dmg: 150, speed: 85, range: 40, target: 'building', color: '#D2691E', radius: 15, hitAir: false, jump: true },
        'valkyrie': { name: 'Valkyrie', icon: 'ðŸª“', cost: 4, type: 'ground', count: 1, hp: 900, dmg: 110, speed: 45, range: 50, target: 'ground', color: '#d35400', radius: 16, hitAir: false, area: true },
        'wizard': { name: 'Wizard', icon: 'ðŸ”¥', cost: 5, type: 'ground', count: 1, hp: 350, dmg: 100, speed: 45, range: 130, target: 'any', color: '#2c3e50', radius: 14, hitAir: true, area: true, projectile: 'fire' },
        'skarmy': { name: 'Skarmy', icon: 'ðŸ’€', cost: 3, type: 'ground', count: 10, hp: 50, dmg: 30, speed: 60, range: 30, target: 'ground', color: '#ecf0f1', radius: 6, hitAir: false },
        'fireball': { name: 'Fireball', icon: 'â˜„ï¸', cost: 4, type: 'spell', radius: 60, dmg: 350, effect: 'fire' },
        'zap': { name: 'Zap', icon: 'âš¡', cost: 2, type: 'spell', radius: 50, dmg: 80, effect: 'zap' }
    };
    const CARD_KEYS = Object.keys(CARDS);

    let lastTime = 0;
    let elixir = 5; let enemyElixir = 5;
    let spawnTimer = 3.0;
    let gameObjects = [];
    let selectedType = 'knight';
    let gameOver = false;

    // --- INIT ---
    function initGame() {
        gameObjects = []; elixir = 5; enemyElixir = 5; gameOver = false;
        document.getElementById('game-over').style.opacity = 0;
        document.getElementById('game-over').style.pointerEvents = 'none';

        // Towers
        createTower(100, CH - 100, true, false); 
        createTower(CW - 100, CH - 100, true, false); 
        createTower(CW / 2, CH - 50, true, true); 

        createTower(100, 100, false, false); 
        createTower(CW - 100, 100, false, false); 
        createTower(CW / 2, 50, false, true); 
    }

    function createTower(x, y, isPlayer, isKing) {
        let hp = isKing ? 2800 : 1600;
        let dmg = isKing ? 60 : 50;
        gameObjects.push(new Tower(x, y, isPlayer, isKing, hp, dmg));
    }

    // --- UI ---
    const cardContainer = document.getElementById('card-selection');
    cardContainer.innerHTML = '';
    CARD_KEYS.forEach(key => {
        const c = CARDS[key];
        const div = document.createElement('div');
        div.className = 'card';
        if(key === selectedType) div.classList.add('selected');
        div.innerHTML = `<span class="card-cost">${c.cost}</span><span class="card-icon">${c.icon}</span><span class="card-name">${c.name}</span>`;
        div.onclick = () => selectCard(key, div);
        cardContainer.appendChild(div);
    });

    function selectCard(type, element) {
        selectedType = type;
        document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
        element.classList.add('selected');
    }

    // --- INPUT (FIXED) ---
    // Changed to pointerdown to support both Mouse and Touch
    canvas.addEventListener('pointerdown', (e) => {
        e.preventDefault(); // Stop scrolling on mobile
        if (gameOver) return;
        
        // --- COORDINATE FIX ---
        // Maps the click exactly to the canvas size, even if zoomed/resized
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        
        const card = CARDS[selectedType];
        if(!card) return; // Safety check

        // Spells can be cast anywhere
        if (card.type === 'spell') {
            if (elixir >= card.cost) {
                castSpell(x, y, true, card);
                elixir -= card.cost;
            } else {
                showFloatText(x, y, "Need " + card.cost + " Elixir!", "#ff4757");
            }
        } 
        // Units only on your side
        else {
            if (y > RIVER_Y) {
                if (elixir >= card.cost) {
                    spawnUnitBatch(x, y, true, card);
                    elixir -= card.cost;
                } else {
                    showFloatText(x, y, "Need " + card.cost + " Elixir!", "#ff4757");
                }
            } else {
                showFloatText(x, y, "Enemy Side!", "#ff4757");
            }
        }
    });

    function spawnUnitBatch(x, y, isPlayer, card) {
        spawnEffect(x, y, 'spawn_ring');
        for(let i=0; i<card.count; i++) {
            let ox = (Math.random() - 0.5) * 30;
            let oy = (Math.random() - 0.5) * 30;
            gameObjects.push(new Unit(x + ox, y + oy, isPlayer, card));
        }
    }

    function castSpell(x, y, isPlayer, card) {
        spawnEffect(x, y, card.effect, card.radius); 
        gameObjects.forEach(obj => {
            if (obj.isPlayer !== isPlayer && !obj.isDead) {
                const dist = Math.hypot(obj.x - x, obj.y - y);
                if (dist <= card.radius) {
                    obj.takeDamage(card.dmg);
                }
            }
        });
    }

    function showFloatText(x, y, text, color) {
        gameObjects.push(new FloatingText(x, y, text, color));
    }

    // --- CLASSES ---

    class GameObject {
        constructor(x, y, isPlayer) {
            this.x = x; this.y = y; this.isPlayer = isPlayer; this.isDead = false;
        }
    }

    class FloatingText extends GameObject {
        constructor(x, y, text, color) {
            super(x, y, true);
            this.text = text; this.color = color; this.life = 1.0;
        }
        update(dt) { this.life -= dt; this.y -= 30 * dt; if(this.life <=0) this.isDead = true; }
        draw() {
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillStyle = this.color; ctx.font = "bold 20px Arial"; 
            ctx.textAlign = "center"; ctx.shadowColor = "black"; ctx.shadowBlur = 4;
            ctx.fillText(this.text, this.x, this.y);
            ctx.shadowBlur = 0; ctx.textAlign = "start"; ctx.globalAlpha = 1;
        }
    }

    class Unit extends GameObject {
        constructor(x, y, isPlayer, stats) {
            super(x, y, isPlayer);
            this.hp = stats.hp; this.maxHp = stats.hp;
            this.dmg = stats.dmg; this.speed = stats.speed;
            this.range = stats.range; this.color = isPlayer ? stats.color : '#ff4757';
            this.radius = stats.radius; 
            this.targetType = stats.target;
            this.hitAir = stats.hitAir;
            this.isFlying = stats.flying || false;
            this.isArea = stats.area || false;
            this.isJump = stats.jump || false; 
            this.projectile = stats.projectile || null;

            this.attackTimer = 0; this.attackRate = 1.2;
            this.aggroRange = 250; 
        }

        update(dt) {
            if (this.attackTimer > 0) this.attackTimer -= dt;
            const target = this.findTarget();

            if (target && this.getDistance(target) <= this.range + target.radius) {
                if (this.attackTimer <= 0) {
                    this.attack(target);
                    this.attackTimer = this.attackRate;
                }
            } else {
                this.move(dt, target);
            }
        }

        move(dt, target) {
            let destX, destY;
            if (!target) {
                destX = this.x < CW/2 ? BRIDGE_LEFT_X : BRIDGE_RIGHT_X;
                destY = this.isPlayer ? 0 : CH;
            } else {
                destX = target.x; destY = target.y;
            }

            // Pathfinding: Bridge Logic
            if (!this.isFlying && !this.isJump) {
                const mySide = this.y > RIVER_Y ? 'bottom' : 'top';
                const destSide = destY > RIVER_Y ? 'bottom' : 'top';
                if (mySide !== destSide) {
                    const inRiverZone = Math.abs(this.y - RIVER_Y) < 30;
                    if (!inRiverZone) {
                        const distLeft = Math.abs(this.x - BRIDGE_LEFT_X);
                        const distRight = Math.abs(this.x - BRIDGE_RIGHT_X);
                        const bridgeX = distLeft < distRight ? BRIDGE_LEFT_X : BRIDGE_RIGHT_X;
                        if (Math.abs(this.x - bridgeX) > 10) {
                            destX = bridgeX; destY = RIVER_Y;
                        }
                    }
                }
            }

            const dx = destX - this.x; const dy = destY - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 0) {
                this.x += (dx / dist) * this.speed * dt;
                this.y += (dy / dist) * this.speed * dt;
            }
        }

        findTarget() {
            let closest = null; let closestDist = Infinity;
            for (const obj of gameObjects) {
                if (obj.isPlayer !== this.isPlayer && !obj.isDead) {
                    if (this.targetType === 'building' && !(obj instanceof Tower)) continue;
                    if (obj.isFlying && !this.hitAir) continue;

                    const d = this.getDistance(obj);
                    let range = (obj instanceof Tower) ? 2000 : this.aggroRange;
                    if (d < range && d < closestDist) {
                        closestDist = d; closest = obj;
                    }
                }
            }
            return closest;
        }

        attack(target) {
            if (this.isArea && !this.projectile) {
                spawnEffect(this.x, this.y, 'spin');
                gameObjects.forEach(obj => {
                    if (obj.isPlayer !== this.isPlayer && !obj.isDead) {
                        if (this.getDistance(obj) <= this.range + 10) {
                             if(!obj.isFlying) obj.takeDamage(this.dmg);
                        }
                    }
                });
                return;
            }

            if (this.range > 50) {
                gameObjects.push(new Projectile(this.x, this.y, target, this.dmg, this.isArea));
            } else {
                target.takeDamage(this.dmg);
            }
        }

        takeDamage(amt) {
            this.hp -= amt;
            spawnEffect(this.x, this.y, 'hit');
            if (this.hp <= 0) {
                this.isDead = true;
                spawnEffect(this.x, this.y, 'skull');
            }
        }

        getDistance(obj) { return Math.hypot(obj.x - this.x, obj.y - this.y); }

        draw() {
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            const shadowY = this.isFlying ? this.y + 20 : this.y + 5;
            ctx.beginPath(); 
            ctx.save(); ctx.translate(this.x, shadowY); ctx.scale(1, 0.5); 
            ctx.arc(0, 0, this.radius, 0, Math.PI*2); 
            ctx.restore(); ctx.fill();

            const pct = Math.max(0, this.hp / this.maxHp);
            ctx.fillStyle = 'red'; ctx.fillRect(this.x - 10, this.y - this.radius - 10, 20, 3);
            ctx.fillStyle = '#2ecc71'; ctx.fillRect(this.x - 10, this.y - this.radius - 10, 20 * pct, 3);

            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
            ctx.fillStyle = this.color; ctx.fill();
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
            
            if(this.isFlying) { ctx.fillStyle='cyan'; ctx.fillRect(this.x-2, this.y-2, 4,4); }
        }
    }

    class Tower extends GameObject {
        constructor(x, y, isPlayer, isKing, hp, dmg) {
            super(x, y, isPlayer);
            this.isKing = isKing; this.hp = hp; this.maxHp = hp;
            this.dmg = dmg; this.range = 160; this.active = !isKing;
            this.radius = isKing ? 35 : 25; this.attackTimer = 0; this.isFlying = false;
        }

        update(dt) {
            if (!this.active) {
                if (this.hp < this.maxHp) this.active = true;
                const friends = gameObjects.filter(o => o instanceof Tower && o.isPlayer === this.isPlayer);
                if (friends.length < 3) this.active = true;
                return;
            }
            if (this.attackTimer > 0) this.attackTimer -= dt;

            for (const obj of gameObjects) {
                if (obj instanceof Unit && obj.isPlayer !== this.isPlayer && !obj.isDead) {
                    if (Math.hypot(obj.x - this.x, obj.y - this.y) <= this.range) {
                        if (this.attackTimer <= 0) {
                            gameObjects.push(new Projectile(this.x, this.y - 20, obj, this.dmg, false, true));
                            this.attackTimer = 0.8;
                        }
                        return;
                    }
                }
            }
        }

        takeDamage(amt) {
            this.hp -= amt;
            if (this.hp <= 0) {
                this.isDead = true;
                spawnEffect(this.x, this.y, 'explosion');
                if (this.isKing) endGame(!this.isPlayer);
            }
        }

        draw() {
            const pct = Math.max(0, this.hp / this.maxHp);
            ctx.fillStyle = this.isPlayer ? '#2980b9' : '#c0392b';
            const s = this.radius * 2;
            ctx.fillRect(this.x - this.radius, this.y - this.radius, s, s);
            
            ctx.fillStyle = 'black'; ctx.fillRect(this.x - 20, this.y - this.radius - 8, 40, 5);
            ctx.fillStyle = '#2ecc71'; ctx.fillRect(this.x - 20, this.y - this.radius - 8, 40 * pct, 5);

            ctx.fillStyle = this.active ? '#ecf0f1' : '#7f8c8d';
            ctx.beginPath();
            if(this.isKing) {
                 ctx.moveTo(this.x-15,this.y-10); ctx.lineTo(this.x-15,this.y-30); 
                 ctx.lineTo(this.x,this.y-20); ctx.lineTo(this.x+15,this.y-30); 
                 ctx.lineTo(this.x+15,this.y-10); ctx.fill();
                 ctx.fillStyle='gold'; ctx.font="20px Arial"; ctx.fillText("ðŸ‘‘", this.x-12, this.y+5);
            } else {
                ctx.arc(this.x, this.y-10, 15, 0, Math.PI*2); ctx.fill();
            }
        }
    }

    class Projectile extends GameObject {
        constructor(x, y, target, dmg, isArea, isTower) {
            super(x, y, false);
            this.target = target; this.dmg = dmg; this.isArea = isArea;
            this.speed = 400; this.isTower = isTower;
        }

        update(dt) {
            if (this.target.isDead) { this.isDead = true; return; }
            const dx = this.target.x - this.x; const dy = this.target.y - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < 10) {
                this.isDead = true;
                if(this.isArea) {
                    spawnEffect(this.x, this.y, 'fire', 40);
                    gameObjects.forEach(obj => {
                        if(obj.isPlayer !== this.target.isPlayer && !obj.isDead) {
                            if(Math.hypot(obj.x - this.x, obj.y - this.y) < 40) obj.takeDamage(this.dmg);
                        }
                    });
                } else {
                    this.target.takeDamage(this.dmg);
                }
            } else {
                this.x += (dx/dist) * this.speed * dt;
                this.y += (dy/dist) * this.speed * dt;
            }
        }
        draw() {
            ctx.fillStyle = this.isTower ? 'yellow' : 'orange';
            ctx.beginPath(); ctx.arc(this.x, this.y, 5, 0, Math.PI*2); ctx.fill();
        }
    }

    class Effect {
        constructor(x, y, type, radius) {
            this.x = x; this.y = y; this.type = type; this.life = 1.0; this.radius = radius || 20;
        }
        update(dt) { this.life -= dt; }
        draw() {
            ctx.globalAlpha = this.life;
            if (this.type === 'fire') {
                ctx.fillStyle = 'orange'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
            } else if (this.type === 'zap') {
                ctx.fillStyle = '#00ccff'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
            } else if (this.type === 'spin') {
                ctx.strokeStyle = 'orange'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(this.x, this.y, 40, 0, Math.PI*2); ctx.stroke();
            } else if (this.type === 'spawn_ring') {
                ctx.strokeStyle = '#fff'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(this.x, this.y, 20*(1-this.life),0,Math.PI*2); ctx.stroke();
            } else if (this.type === 'skull') {
                ctx.fillStyle = '#ccc'; ctx.font="12px Arial"; ctx.fillText("â˜ ï¸", this.x-6, this.y);
            }
            ctx.globalAlpha = 1.0;
        }
    }

    // --- GAME LOOP ---
    function spawnEffect(x, y, type, r) { gameObjects.push(new Effect(x, y, type, r)); }

    function endGame(playerWon) {
        gameOver = true;
        const screen = document.getElementById('game-over');
        const title = document.getElementById('go-title');
        screen.style.opacity = 1; screen.style.pointerEvents = 'auto';
        title.innerText = playerWon ? "VICTORY!" : "DEFEAT";
        title.style.color = playerWon ? "#2ecc71" : "#e74c3c";
    }

    function enemyAI(dt) {
        enemyElixir += ELIXIR_REGEN * dt / 1.5;
        if(enemyElixir > ELIXIR_MAX) enemyElixir = ELIXIR_MAX;
        spawnTimer -= dt;

        if (spawnTimer <= 0) {
            const randKey = CARD_KEYS[Math.floor(Math.random() * CARD_KEYS.length)];
            const card = CARDS[randKey];
            
            if (enemyElixir >= card.cost) {
                if(card.type === 'spell') {
                    castSpell(CW/2, CH-50, false, card);
                } else {
                    const laneX = Math.random() > 0.5 ? BRIDGE_LEFT_X : BRIDGE_RIGHT_X;
                    const ox = (Math.random()-0.5)*40;
                    spawnUnitBatch(laneX + ox, 50, false, card);
                }
                enemyElixir -= card.cost;
                spawnTimer = 2.5 + Math.random() * 3;
            }
        }
    }

    function resolveCollisions() {
        const units = gameObjects.filter(o => o instanceof Unit);
        const towers = gameObjects.filter(o => o instanceof Tower);

        for(let i=0; i<units.length; i++) {
            const u1 = units[i];
            
            for(let j=i+1; j<units.length; j++) {
                const u2 = units[j];
                if(u1.isFlying !== u2.isFlying) continue;

                const dist = Math.hypot(u1.x - u2.x, u1.y - u2.y);
                const min = u1.radius + u2.radius;
                if(dist < min && dist > 0) {
                    const overlap = min - dist;
                    const dx = (u1.x - u2.x)/dist; const dy = (u1.y - u2.y)/dist;
                    u1.x += dx*overlap*0.5; u1.y += dy*overlap*0.5;
                    u2.x -= dx*overlap*0.5; u2.y -= dy*overlap*0.5;
                }
            }

            for(const t of towers) {
                if(u1.isFlying) continue; 
                
                const dist = Math.hypot(u1.x - t.x, u1.y - t.y);
                const min = u1.radius + t.radius;
                if(dist < min && dist > 0) {
                    const overlap = min - dist;
                    const dx = (u1.x - t.x)/dist; const dy = (u1.y - t.y)/dist;
                    u1.x += dx * overlap; 
                    u1.y += dy * overlap;
                }
            }
        }
    }

    function loop(timestamp) {
        try {
            const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
            lastTime = timestamp;

            if (!gameOver) {
                if (elixir < ELIXIR_MAX) elixir += ELIXIR_REGEN * dt;
                document.getElementById('elixir-fill').style.width = (elixir/ELIXIR_MAX*100)+'%';
                document.getElementById('elixir-text').innerText = Math.floor(elixir);

                const cardDivs = document.querySelectorAll('.card');
                cardDivs.forEach((div, idx) => {
                    const key = CARD_KEYS[idx];
                    if(CARDS[key].cost > elixir) div.style.filter = "grayscale(1) opacity(0.5)";
                    else div.style.filter = "none";
                });

                enemyAI(dt);
                resolveCollisions();
                gameObjects.sort((a,b) => a.y - b.y);

                for(let i=gameObjects.length-1; i>=0; i--) {
                    let obj = gameObjects[i];
                    obj.update(dt);
                    if(obj.life && obj.life<=0) gameObjects.splice(i,1);
                    else if(obj.isDead) gameObjects.splice(i,1);
                }
            }

            ctx.clearRect(0, 0, CW, CH);
            ctx.fillStyle = '#3b8c3b'; ctx.fillRect(0,0,CW,CH);
            ctx.fillStyle = '#3498db'; ctx.fillRect(0, RIVER_Y - 20, CW, 40);
            ctx.fillStyle = '#8e44ad'; 
            ctx.fillRect(BRIDGE_LEFT_X-25, RIVER_Y-22, 50, 44);
            ctx.fillRect(BRIDGE_RIGHT_X-25, RIVER_Y-22, 50, 44);

            for(const obj of gameObjects) obj.draw();
            requestAnimationFrame(loop);
            
        } catch (e) {
            console.error(e);
            requestAnimationFrame(loop);
        }
    }

    initGame();
    requestAnimationFrame(loop);

</script>
</body>
</html>
