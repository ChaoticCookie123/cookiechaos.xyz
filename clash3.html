<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Clash Simple</title>
    <style>
        body {
            background-color: #222; margin: 0; overflow: hidden;
            display: flex; justify-content: center; align-items: center;
            font-family: sans-serif; user-select: none;
        }
        #game-frame {
            position: relative; width: 420px; height: 720px; background: #3b8c3b;
            border: 4px solid #555; overflow: hidden;
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* UI */
        #ui-layer { position: absolute; bottom: 0; width: 100%; height: 160px; pointer-events: none; }
        
        #elixir-bar {
            width: 80%; height: 20px; margin: 0 auto 10px auto;
            background: #111; border: 2px solid #fff; border-radius: 10px;
            position: relative; pointer-events: auto;
        }
        #elixir-fill { height: 100%; background: #d0f; width: 50%; transition: width 0.1s; }
        #elixir-text {
            position: absolute; top: 0; width: 100%; text-align: center; color: #fff;
            font-weight: bold; line-height: 20px; font-size: 14px;
        }

        #hand {
            display: flex; justify-content: center; gap: 10px; pointer-events: auto;
        }
        .card {
            width: 70px; height: 90px; background: #444; border: 2px solid #888;
            border-radius: 6px; display: flex; flex-direction: column; align-items: center;
            cursor: pointer; position: relative;
        }
        .card.selected { border-color: gold; background: #555; transform: translateY(-10px); }
        .card.disabled { filter: grayscale(1); opacity: 0.5; }
        .cost { position: absolute; top: -5px; left: -5px; background: #d0f; border-radius: 50%; width: 20px; height: 20px; text-align: center; line-height: 20px; color: white; font-weight: bold; border: 1px solid white; }
        .icon { font-size: 35px; margin-top: 15px; }
        .name { font-size: 10px; color: #ccc; margin-top: 5px; font-weight: bold; }

        #toast {
            position: absolute; top: 30%; width: 100%; text-align: center;
            color: white; font-size: 20px; font-weight: bold; text-shadow: 2px 2px 0 #000;
            pointer-events: none; opacity: 0; transition: opacity 0.5s;
        }
    </style>
</head>
<body>

<div id="game-frame">
    <canvas id="cvs" width="420" height="720"></canvas>
    
    <div id="toast">Msg</div>

    <div id="ui-layer">
        <div id="elixir-bar">
            <div id="elixir-fill"></div>
            <div id="elixir-text">5</div>
        </div>
        <div id="hand"></div>
    </div>
</div>

<script>
    const cvs = document.getElementById('cvs');
    const ctx = cvs.getContext('2d');
    
    // Config
    const W = 420, H = 720;
    const RIVER_Y = H / 2 - 30;
    const BRIDGE_L = 90, BRIDGE_R = W - 90;
    
    // Card Data
    const CARDS = {
        'knight': { name: 'Knight', cost: 3, icon: 'âš”ï¸', hp: 800, dmg: 80, spd: 50, range: 30, type: 'ground' },
        'archer': { name: 'Archer', cost: 3, icon: 'ðŸ¹', hp: 300, dmg: 60, spd: 60, range: 120, type: 'ground', count: 2 },
        'giant':  { name: 'Giant', cost: 5, icon: 'ðŸ‘¹', hp: 2500, dmg: 150, spd: 30, range: 30, type: 'building' },
        'hog':    { name: 'Hog', cost: 4, icon: 'ðŸ”¨', hp: 1000, dmg: 180, speed: 90, range: 30, type: 'building' },
        'minion': { name: 'Minions', cost: 3, icon: 'ðŸ¦‡', hp: 150, dmg: 40, spd: 80, range: 30, type: 'air', count: 3 },
        'baby':   { name: 'Baby Drag', cost: 4, icon: 'ðŸ²', hp: 900, dmg: 100, spd: 60, range: 90, type: 'air', area: true },
        'skarmy': { name: 'Skarmy', cost: 3, icon: 'ðŸ’€', hp: 50, dmg: 30, spd: 70, range: 20, type: 'ground', count: 6 },
        'ball':   { name: 'Fireball', cost: 4, icon: 'â˜„ï¸', type: 'spell', radius: 80, dmg: 400 }
    };
    const DECK = Object.keys(CARDS);

    // State
    let elixir = 5;
    let entities = [];
    let projectiles = [];
    let lastTime = 0;
    let spawnTimer = 3.0;
    
    // Cycle
    let deckQueue = [];
    let hand = [];
    let selectedIdx = null;

    // --- SETUP ---
    function init() {
        // Init Deck
        deckQueue = [...DECK].sort(() => Math.random() - 0.5);
        for(let i=0; i<4; i++) hand.push(deckQueue.shift());
        renderHand();

        // Towers
        addEntity(new Entity(90, 550, true, 'tower'));
        addEntity(new Entity(W-90, 550, true, 'tower'));
        addEntity(new Entity(W/2, 620, true, 'king')); // Player King
        
        addEntity(new Entity(90, 100, false, 'tower'));
        addEntity(new Entity(W-90, 100, false, 'tower'));
        addEntity(new Entity(W/2, 40, false, 'king')); // Enemy King

        requestAnimationFrame(loop);
    }

    function renderHand() {
        const h = document.getElementById('hand');
        h.innerHTML = '';
        hand.forEach((k, i) => {
            let c = CARDS[k];
            let d = document.createElement('div');
            d.className = 'card' + (i===selectedIdx ? ' selected' : '');
            d.innerHTML = `<div class="cost">${c.cost}</div><div class="icon">${c.icon}</div><div class="name">${c.name}</div>`;
            d.onclick = () => { selectedIdx = i; renderHand(); };
            h.appendChild(d);
        });
    }

    // --- INPUT ---
    cvs.addEventListener('pointerdown', e => {
        const rect = cvs.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (W / rect.width);
        const y = (e.clientY - rect.top) * (H / rect.height);

        if (selectedIdx === null) return msg("Select a card!");
        let card = CARDS[hand[selectedIdx]];

        if (elixir < card.cost) return msg("Not enough Elixir!");
        if (card.type !== 'spell' && y < RIVER_Y) return msg("Enemy Side!");

        // Play Card
        elixir -= card.cost;
        if (card.type === 'spell') {
            castSpell(x, y, true, card);
        } else {
            let count = card.count || 1;
            for(let i=0; i<count; i++) {
                let ox = (Math.random()-0.5)*30;
                let oy = (Math.random()-0.5)*30;
                addEntity(new Entity(x+ox, y+oy, true, 'unit', card));
            }
        }

        // Cycle
        deckQueue.push(hand[selectedIdx]);
        hand[selectedIdx] = deckQueue.shift();
        selectedIdx = null;
        renderHand();
    });

    function msg(txt) {
        let t = document.getElementById('toast');
        t.innerText = txt; t.style.opacity=1;
        setTimeout(()=>t.style.opacity=0, 1000);
    }

    function addEntity(e) {
        if(entities.length < 80) entities.push(e);
    }

    function castSpell(x, y, isPlayer, card) {
        // Simple visual circle
        entities.forEach(e => {
            if (e.isPlayer !== isPlayer && Math.hypot(e.x-x, e.y-y) < card.radius) {
                e.hp -= card.dmg;
            }
        });
        projectiles.push({x:x, y:y, type:'boom', life:0.5});
    }

    // --- CLASSES ---
    class Entity {
        constructor(x, y, isPlayer, role, stats) {
            this.x = x; this.y = y; this.isPlayer = isPlayer; this.role = role;
            
            if (role === 'unit') {
                this.hp = stats.hp; this.maxHp = stats.hp;
                this.dmg = stats.dmg; this.speed = stats.spd || 50;
                this.range = stats.range; this.icon = stats.icon;
                this.targetType = stats.type; // 'building'
                this.flying = (stats.type === 'air');
                this.waypoints = [];
                
                // --- SIMPLE WAYPOINT SYSTEM ---
                // 1. Go to Bridge
                // 2. Go to King
                if (!this.flying) {
                    let bridgeX = Math.abs(x - BRIDGE_L) < Math.abs(x - BRIDGE_R) ? BRIDGE_L : BRIDGE_R;
                    let bridgeY = RIVER_Y + 15; // Middle of river height approx
                    this.waypoints.push({x: bridgeX, y: bridgeY});
                }
                // Final Goal
                this.waypoints.push({x: W/2, y: isPlayer ? 40 : 620});
            } else {
                // Tower
                this.hp = role==='king'?3000:1800; this.maxHp = this.hp;
                this.dmg = 80; this.speed = 0; this.range = 150;
                this.icon = role==='king'?'ðŸ‘‘':'ðŸ°';
                this.radius = 25;
            }
            this.radius = 15; this.cooldown = 0;
        }

        update(dt) {
            if (this.cooldown > 0) this.cooldown -= dt;

            // Find Target
            let target = null;
            let minDist = 300;

            for(let e of entities) {
                if(e.isPlayer === this.isPlayer || e.hp <= 0) continue;
                if(this.targetType === 'building' && e.role === 'unit') continue; // Giant logic
                
                let d = Math.hypot(e.x - this.x, e.y - this.y);
                if(d < minDist) { minDist = d; target = e; }
            }

            // Act
            if (target && minDist <= this.range + target.radius) {
                // Attack
                if(this.cooldown <= 0) {
                    projectiles.push({
                        x:this.x, y:this.y-10, tx:target.x, ty:target.y-10, 
                        dmg:this.dmg, speed:300, isPlayer:this.isPlayer
                    });
                    this.cooldown = 1.0;
                }
            } else if (this.speed > 0) {
                // Move
                let tx, ty;
                
                // If we have a target close by, chase it
                if (target && minDist < 250) {
                    tx = target.x; ty = target.y;
                } else if (this.waypoints.length > 0) {
                    // Follow Waypoints
                    tx = this.waypoints[0].x;
                    ty = this.waypoints[0].y;
                    if (Math.hypot(tx-this.x, ty-this.y) < 10) {
                        this.waypoints.shift(); // Reached point, go next
                    }
                } else {
                    // Fallback (shouldn't happen with waypoints)
                    tx = W/2; ty = this.isPlayer ? 40 : 620;
                }

                let angle = Math.atan2(ty - this.y, tx - this.x);
                this.x += Math.cos(angle) * this.speed * dt;
                this.y += Math.sin(angle) * this.speed * dt;
            }
        }

        draw() {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
            
            // Icon
            ctx.font = '24px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
            ctx.fillText(this.icon, this.x, this.y-5);

            // HP
            let pct = this.hp/this.maxHp;
            ctx.fillStyle = 'red'; ctx.fillRect(this.x-10, this.y-25, 20, 4);
            ctx.fillStyle = '#0f0'; ctx.fillRect(this.x-10, this.y-25, 20*pct, 4);
        }
    }

    // --- MAIN LOOP ---
    function loop(now) {
        const dt = Math.min((now - lastTime) / 1000, 0.1);
        lastTime = now;

        // UI
        if(elixir < 10) elixir += 0.5 * dt;
        document.getElementById('elixir-fill').style.width = (elixir*10)+'%';
        document.getElementById('elixir-text').innerText = Math.floor(elixir);
        
        hand.forEach((k,i) => {
            let el = document.getElementById('hand-'+i);
            if(el) {
                if(CARDS[k].cost > elixir) el.classList.add('disabled');
                else el.classList.remove('disabled');
            }
        });

        // AI Spawner
        spawnTimer -= dt;
        if(spawnTimer <= 0) {
            let keys = ['knight','archer','giant'];
            let rk = keys[Math.floor(Math.random()*keys.length)];
            let lane = Math.random()>0.5 ? BRIDGE_L : BRIDGE_R;
            addEntity(new Entity(lane, 20, false, 'unit', CARDS[rk]));
            spawnTimer = 4.0;
        }

        // Entities
        entities.sort((a,b) => a.y - b.y);
        for(let i=entities.length-1; i>=0; i--) {
            entities[i].update(dt);
            if(entities[i].hp <= 0) entities.splice(i,1);
        }

        // Projectiles
        for(let i=projectiles.length-1; i>=0; i--) {
            let p = projectiles[i];
            if(p.type === 'boom') {
                p.life -= dt;
                if(p.life <= 0) projectiles.splice(i,1);
            } else {
                let dx = p.tx - p.x, dy = p.ty - p.y;
                let d = Math.hypot(dx, dy);
                if(d < 10) {
                    // Hit logic
                    let hit = entities.find(e => e.isPlayer !== p.isPlayer && Math.hypot(e.x-p.x, e.y-p.y) < 20);
                    if(hit) hit.hp -= p.dmg;
                    projectiles.splice(i,1);
                } else {
                    p.x += (dx/d)*p.speed*dt;
                    p.y += (dy/d)*p.speed*dt;
                }
            }
        }

        draw();
        requestAnimationFrame(loop);
    }

    function draw() {
        ctx.fillStyle = '#3b8c3b'; ctx.fillRect(0,0,W,H);
        ctx.fillStyle = '#4fa3e3'; ctx.fillRect(0, RIVER_Y, W, 30);
        ctx.fillStyle = '#8d6e63'; 
        ctx.fillRect(BRIDGE_L-15, RIVER_Y-10, 30, 50);
        ctx.fillRect(BRIDGE_R-15, RIVER_Y-10, 30, 50);

        entities.forEach(e => e.draw());
        
        projectiles.forEach(p => {
            if(p.type === 'boom') {
                ctx.fillStyle='orange'; ctx.beginPath(); ctx.arc(p.x, p.y, 10, 0, Math.PI*2); ctx.fill();
            } else {
                ctx.fillStyle='yellow'; ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill();
            }
        });
    }

    init();
</script>
</body>
</html>
