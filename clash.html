<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mini Clash Royale - Fixed!</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100vh; overflow: hidden; font-family: Arial, sans-serif; background: #111; color: white; }
    .container { 
      width: 100%; 
      max-width: 375px; 
      height: 100vh; 
      margin: 0 auto; 
      display: flex; 
      flex-direction: column; 
    }
    #game { 
      flex: 1; 
      position: relative; 
      background: linear-gradient(to bottom, #2d3748 0%, #4a5568 48%, #718096 52%, #2d3748 100%); 
      overflow: hidden; 
      cursor: default;
    }
    .bridge {
      position: absolute;
      left: 50%;
      width: 60px;
      height: 80px;
      background: linear-gradient(#d4af37, #b8860b);
      transform: translateX(-50%);
      top: 50%;
      margin-top: -40px;
      border-radius: 30px 30px 10px 10px;
      box-shadow: 0 0 20px gold, inset 0 0 10px rgba(255,255,0,0.3);
    }
    .tower {
      position: absolute;
      width: 60px;
      height: 100px;
      background: linear-gradient(#4a5568, #2d3748);
      border: 5px solid #a0aec0;
      border-radius: 15px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.7);
    }
    .tower.king {
      width: 80px;
      height: 130px;
      border-color: gold;
      border-width: 6px;
      box-shadow: 0 5px 20px gold;
    }
    .health-bar {
      position: absolute;
      top: -20px;
      left: 5px;
      right: 5px;
      height: 10px;
      background: #333;
      border-radius: 5px;
      overflow: hidden;
      box-shadow: 0 2px 5px rgba(0,0,0,0.5);
    }
    .health {
      height: 100%;
      background: linear-gradient(#48bb78, #38a169);
      transition: width 0.3s ease;
      border-radius: 3px;
    }
    .health.low { 
      background: linear-gradient(#f56565, #c53030); 
    }
    .troop {
      position: absolute;
      width: 50px;
      height: 50px;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      border-radius: 12px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.6);
      transition: all 0.15s ease;
    }
    .troop.player { 
      background-image: url('https://royaleapi.com/static/img/cards/knight.png'); 
    }
    .troop.enemy { 
      background-image: url('https://royaleapi.com/static/img/cards/goblins.png'); 
    }
    .troop.attacking {
      transform: scale(1.1);
    }
    #ui {
      padding: 10px;
      background: rgba(0,0,0,0.85);
      border-top: 3px solid #4a5568;
    }
    #elixir-bar {
      height: 12px;
      background: #333;
      margin-bottom: 8px;
      border-radius: 6px;
      overflow: hidden;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
    }
    #elixir {
      height: 100%;
      background: linear-gradient(90deg, #9f7aea, #7f9cf5);
      transition: width 0.3s ease;
      box-shadow: 0 0 10px #9f7aea;
    }
    #elixir-text {
      text-align: center;
      font-size: 16px;
      font-weight: bold;
      margin-bottom: 12px;
      text-shadow: 0 1px 2px #000;
    }
    #cards {
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    .card {
      width: 65px;
      height: 90px;
      background: linear-gradient(145deg, #4a5568, #2d3748) url('https://royaleapi.com/static/img/cards/knight.png') center/cover;
      border-radius: 12px;
      border: 3px solid #a0aec0;
      position: relative;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.6);
      transition: all 0.2s ease;
    }
    .card::after {
      content: attr(data-cost);
      position: absolute;
      bottom: 6px;
      right: 6px;
      background: rgba(0,0,0,0.8);
      color: gold;
      font-weight: bold;
      font-size: 18px;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.5);
    }
    .card:hover:not(.disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(0,0,0,0.7);
    }
    .card.selected {
      border-color: gold;
      box-shadow: 0 0 20px gold;
    }
    .card.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="game">
      <!-- Enemy Towers (Top) -->
      <div class="tower king" style="left: 50%; transform: translateX(-50%); top: 20px;" id="enemy-king"></div>
      <div class="tower" style="left: 40px; top: 20px;" id="enemy-left"></div>
      <div class="tower" style="right: 40px; top: 20px;" id="enemy-right"></div>

      <!-- Player Towers (Bottom) -->
      <div class="tower king" style="left: 50%; transform: translateX(-50%); bottom: 20px;" id="player-king"></div>
      <div class="tower" style="left: 40px; bottom: 20px;" id="player-left"></div>
      <div class="tower" style="right: 40px; bottom: 20px;" id="player-right"></div>

      <div class="bridge"></div>
    </div>

    <div id="ui">
      <div id="elixir-bar"><div id="elixir"></div></div>
      <div id="elixir-text">10 / 10</div>
      <div id="cards">
        <div class="card" data-cost="3"></div>
        <div class="card" data-cost="3"></div>
        <div class="card" data-cost="4"></div>
        <div class="card" data-cost="2"></div>
      </div>
    </div>
  </div>

  <script>
    // Game State
    let elixir = 10;
    let maxElixir = 10;
    let playerTroops = [];
    let enemyTroops = [];
    let towers = {
      'player-king': { hp: 3000, maxHp: 3000 },
      'player-left': { hp: 1500, maxHp: 1500 },
      'player-right': { hp: 1500, maxHp: 1500 },
      'enemy-king': { hp: 3000, maxHp: 3000 },
      'enemy-left': { hp: 1500, maxHp: 1500 },
      'enemy-right': { hp: 1500, maxHp: 1500 }
    };
    let selectedCard = null;

    const game = document.getElementById('game');
    const elixirBar = document.getElementById('elixir');
    const elixirText = document.getElementById('elixir-text');

    // Create health bars
    Object.keys(towers).forEach(id => {
      const tower = document.getElementById(id);
      const hb = document.createElement('div');
      hb.className = 'health-bar';
      const inner = document.createElement('div');
      inner.className = 'health';
      hb.appendChild(inner);
      tower.appendChild(hb);
    });

    function updateHealthBars() {
      Object.keys(towers).forEach(id => {
        const t = towers[id];
        const towerEl = document.getElementById(id);
        const healthEl = towerEl.querySelector('.health');
        const percent = Math.max(0, (t.hp / t.maxHp) * 100);
        healthEl.style.width = percent + '%';
        healthEl.classList.toggle('low', percent < 30);
      });
    }

    function checkWin() {
      if (towers['player-king'].hp <= 0) {
        alert('ðŸ’€ YOU LOSE! King Tower Destroyed! ðŸ’€');
        location.reload();
      }
      if (towers['enemy-king'].hp <= 0) {
        alert('ðŸ† YOU WIN! Enemy King Destroyed! ðŸ†');
        location.reload();
      }
    }

    // Elixir System
    function updateElixir() {
      elixirBar.style.width = (elixir / maxElixir * 100) + '%';
      elixirText.textContent = `${elixir} / ${maxElixir}`;
      document.querySelectorAll('.card').forEach(card => {
        card.classList.toggle('disabled', elixir < parseInt(card.dataset.cost));
      });
    }
    setInterval(() => {
      if (elixir < maxElixir) {
        elixir = Math.min(maxElixir, elixir + 1);
        updateElixir();
      }
    }, 2600); // Authentic regen time

    // Card Selection
    document.querySelectorAll('.card').forEach((card, index) => {
      card.addEventListener('click', () => {
        if (elixir < parseInt(card.dataset.cost)) return;
        if (selectedCard === card) {
          selectedCard = null;
          game.style.cursor = 'default';
          card.classList.remove('selected');
        } else {
          document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
          selectedCard = card;
          game.style.cursor = 'crosshair';
          card.classList.add('selected');
        }
      });
    });

    // Place Troop
    game.addEventListener('click', (e) => {
      if (!selectedCard) return;
      const rect = game.getBoundingClientRect();
      let x = e.clientX - rect.left;
      let y = e.clientY - rect.top;
      if (y < rect.height * 0.45) { // Slightly more than half for bridge
        return; // Can't place in enemy half
      }
      const cost = parseInt(selectedCard.dataset.cost);
      if (elixir < cost) return;
      elixir -= cost;
      updateElixir();
      spawnTroop(x, y, 'player');
      selectedCard.classList.remove('selected');
      selectedCard = null;
      game.style.cursor = 'default';
    });

    function spawnTroop(x, y, side) {
      const troop = document.createElement('div');
      troop.className = `troop ${side}`;
      troop.style.left = (x - 25) + 'px';
      troop.style.top = (y - 25) + 'px';
      troop.dataset.side = side;
      troop.dataset.hp = side === 'player' ? '1400' : '500';
      troop.dataset.damage = side === 'player' ? '120' : '70';
      troop.dataset.speed = '1.8';
      troop.dataset.attackCooldown = '0';
      game.appendChild(troop);
      (side === 'player' ? playerTroops : enemyTroops).push(troop);
    }

    // Enemy AI: Places troops periodically
    setInterval(() => {
      const rect = game.getBoundingClientRect();
      const x = 50 + Math.random() * (rect.width - 100);
      const y = 50 + Math.random() * 120; // Enemy half
      spawnTroop(x, y, 'enemy');
      if (Math.random() < 0.4) {
        setTimeout(() => {
          const x2 = 50 + Math.random() * (rect.width - 100);
          const y2 = 50 + Math.random() * 120;
          spawnTroop(x2, y2, 'enemy');
        }, 600);
      }
    }, 4500 + Math.random() * 3000);

    // Utility: Get element center
    function getCenter(el) {
      return {
        x: el.offsetLeft + (el.offsetWidth / 2),
        y: el.offsetTop + (el.offsetHeight / 2)
      };
    }

    // Main Game Loop
    function gameLoop() {
      // Process player troops
      for (let i = playerTroops.length - 1; i >= 0; i--) {
        const troop = playerTroops[i];
        if (!troop.isConnected) {
          playerTroops.splice(i, 1);
          continue;
        }
        updateTroop(troop, true);
      }
      // Process enemy troops
      for (let i = enemyTroops.length - 1; i >= 0; i--) {
        const troop = enemyTroops[i];
        if (!troop.isConnected) {
          enemyTroops.splice(i, 1);
          continue;
        }
        updateTroop(troop, false);
      }
      requestAnimationFrame(gameLoop);
    }

    function updateTroop(troop, isPlayer) {
      const tc = getCenter(troop);
      let target = null;
      let minDist = Infinity;

      // Find closest enemy troop
      const enemyTroopsList = isPlayer ? enemyTroops : playerTroops;
      enemyTroopsList.forEach(enemy => {
        if (!enemy.isConnected) return;
        const ec = getCenter(enemy);
        const dist = Math.hypot(ec.x - tc.x, ec.y - tc.y);
        if (dist < minDist) {
          minDist = dist;
          target = enemy;
        }
      });

      // If no enemy troop, target closest enemy tower
      if (!target) {
        const enemyTowerIds = isPlayer ? ['enemy-king', 'enemy-left', 'enemy-right'] : ['player-king', 'player-left', 'player-right'];
        enemyTowerIds.forEach(id => {
          const tower = document.getElementById(id);
          if (!tower) return;
          const ttc = getCenter(tower);
          const dist = Math.hypot(ttc.x - tc.x, ttc.y - tc.y);
          if (dist < minDist) {
            minDist = dist;
            target = tower;
          }
        });
      }

      if (target) {
        const ttc = getCenter(target);
        const dx = ttc.x - tc.x;
        const dy = ttc.y - tc.y;
        const dist = Math.hypot(dx, dy);

        if (dist < 75) { // Attack range
          const cooldown = parseInt(troop.dataset.attackCooldown);
          if (cooldown <= 0) {
            troop.classList.add('attacking');
            setTimeout(() => troop.classList.remove('attacking'), 150);
            const dmg = parseInt(troop.dataset.damage);
            if (target.classList && target.classList.contains('troop')) {
              // Damage enemy troop
              let hp = parseInt(target.dataset.hp) - dmg;
              target.dataset.hp = Math.max(0, hp);
              if (hp <= 0) {
                target.remove();
              }
            } else if (target.id && towers[target.id]) {
              // Damage tower
              towers[target.id].hp = Math.max(0, towers[target.id].hp - dmg);
              updateHealthBars();
              checkWin();
            }
            troop.dataset.attackCooldown = '45'; // ~0.75s cooldown
          }
        } else {
          // Move towards target
          const angle = Math.atan2(dy, dx);
          const speed = parseFloat(troop.dataset.speed);
          const newX = tc.x + Math.cos(angle) * speed;
          const newY = tc.y + Math.sin(angle) * speed;
          troop.style.left = (newX - 25) + 'px';
          troop.style.top = (newY - 25) + 'px';
        }
      }

      // Decrement cooldown
      const cd = parseInt(troop.dataset.attackCooldown);
      if (cd > 0) {
        troop.dataset.attackCooldown = (cd - 1).toString();
      }
    }

    // Init
    updateElixir();
    updateHealthBars();
    gameLoop();
  </script>
</body>
</html>
