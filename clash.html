<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clash Clone - Emoji Graphics</title>
    
    <style>
        /* --- General Styling --- */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 110vh; 
            margin: 0;
            background-color: #2c2c2c; 
            font-family: 'Arial', sans-serif;
            flex-direction: column;
        }

        /* --- Game Container --- */
        #game-container {
            border: 12px solid #5a3e2a; 
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            overflow: hidden; 
        }

        #gameCanvas {
            display: block;
            cursor: pointer;
        }

        /* --- UI Overlay --- */
        #ui-overlay {
            width: 100%;
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 10px 0;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.95), rgba(0, 0, 0, 0.75));
            color: white;
            position: absolute;
            bottom: 0;
            left: 0;
            box-sizing: border-box;
            border-top: 3px solid #777;
            text-shadow: 1px 1px 2px black;
        }
        
        #ui-overlay p {
            margin: 0 10px;
            font-size: 1.2em;
            display: flex;
            align-items: center;
        }
        
        .icon {
            font-size: 1.8em;
            margin-right: 5px;
            text-shadow: none;
        }

        /* --- Card Deck --- */
        #card-deck {
            display: flex;
            gap: 5px; 
            min-width: 400px; 
        }
        
        /* Next Card Preview */
        #next-card-preview {
            position: absolute;
            left: 50%;
            bottom: 80px; 
            transform: translateX(-50%);
            color: white;
            padding: 5px;
            font-size: 0.8em;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            border: 1px solid #aaa;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
            pointer-events: none; 
        }

        .deploy-card {
            padding: 8px 5px; 
            color: white;
            font-weight: bold;
            border: 3px solid #ffd700;
            cursor: pointer;
            border-radius: 8px;
            transition: transform 0.1s, box-shadow 0.1s;
            box-shadow: 0 4px #c43500;
            min-width: 80px; 
            text-align: center;
            line-height: 1.1;
            font-size: 0.85em; 
            position: relative;
        }
        
        .deploy-card:disabled {
            background-color: #555 !important;
            border-color: #333;
            cursor: not-allowed;
            box-shadow: none;
            color: #ccc;
        }
        
        .deploy-card:not(:disabled):active {
            box-shadow: 0 2px #c43500;
            transform: translateY(2px);
        }
        
        /* Individual card colors (mapped in JS) */
        .card-knight { background-color: #007bff; } 
        .card-archer { background-color: #ff4500; } 
        .card-goblins { background-color: #4CAF50; } 
        .card-minipekka { background-color: #800080; } 
        .card-giant { background-color: #00CED1; } 
        .card-skeletons { background-color: #cccccc; }
        .card-valkyrie { background-color: #ff69b4; }
        .card-hogrider { background-color: #cc5500; }
        .card-fireball { background-color: #dc143c; }

        .selected-card {
            box-shadow: 0 0 15px 5px yellow !important;
            border-color: yellow !important;
            transform: scale(1.05);
        }
        
        /* Elixir cost badge */
        .elixir-cost {
            position: absolute;
            top: -10px;
            left: 5px;
            background: #6a0dad;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            line-height: 20px;
            font-size: 0.7em;
            border: 2px solid gold;
        }

        /* --- Game Over Modal --- */
        #gameOverModal {
            display: none; 
            position: absolute;
            z-index: 10;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); 
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: linear-gradient(#4d1818, #333333); 
            margin: 15% auto;
            padding: 40px;
            border: 5px solid gold;
            width: 70%;
            text-align: center;
            color: white;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.5);
        }

        .modal-content h2 {
            font-size: 3em;
            margin-bottom: 20px;
            color: yellow;
            text-shadow: 2px 2px #000;
        }

        .modal-content button {
            background-color: #c43500;
            color: white;
            padding: 10px 20px;
            border: 2px solid #ffd700;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.2em;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    
    <h1>‚öîÔ∏è Strategic Clash Clone</h1>

    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="800"></canvas>
        
        <div id="gameOverModal">
            <div class="modal-content">
                <h2 id="modalText"></h2>
                <button onclick="window.location.reload()">Restart Game</button>
            </div>
        </div>

        <div id="next-card-preview"></div>

        <div id="ui-overlay">
            <p><span class="icon">‚ù§Ô∏è</span> King Tower: <span id="playerHealth">2000</span></p>
            
            <div id="card-deck">
                </div>
            
            <p><span class="icon">üß™</span> Elixir: <span id="elixirCount">10</span>/10</p>
        </div>
    </div>

    <script>
        // --- Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const GAME_WIDTH = canvas.width;
        const GAME_HEIGHT = canvas.height; 
        const MID_Y = GAME_HEIGHT / 2; 
        
        const CENTER_LANE_X = GAME_WIDTH / 2; 

        const INITIAL_DEPLOY_Y = MID_Y + 50; 
        const DEPLOY_Y_EXPANDED = 50; 
        
        let deploymentLines = {
            left: INITIAL_DEPLOY_Y,
            right: INITIAL_DEPLOY_Y
        };
        
        const LANE_WIDTH = 140;
        const LEFT_LANE_X_CENTER = GAME_WIDTH * 0.25; 
        const RIGHT_LANE_X_CENTER = GAME_WIDTH * 0.75; 
        
        const LEFT_LANE_MIN_X = LEFT_LANE_X_CENTER - LANE_WIDTH / 2;
        const LEFT_LANE_MAX_X = LEFT_LANE_X_CENTER + LANE_WIDTH / 2;
        const RIGHT_LANE_MIN_X = RIGHT_LANE_X_CENTER - LANE_WIDTH / 2;
        const RIGHT_LANE_MAX_X = RIGHT_LANE_X_CENTER + LANE_WIDTH / 2;
        
        // TOWER CONSTANTS
        const TOWER_RANGE = 300; 
        const TOWER_DAMAGE = 50;
        const TOWER_ATTACK_COOLDOWN = 1.5;

        // --- Game State Variables ---
        let playerHealth = 2000;
        let elixir = 10;
        let lastTime = 0;
        let elixirTimer = 0;
        let enemySpawnTimer = 0; 
        let isGameOver = false; 
        const ELIXIR_REGEN_RATE = 1; 
        const ENEMY_SPAWN_RATE = 5; 
        let selectedCardIndex = null; 
        
        let playerKingActive = false;
        let enemyKingActive = false;

        let fullDeck = []; 
        let deck = [];     
        let hand = [];     
        let nextCardIndex = 0; 

        const gameObjects = []; 

        // --- EMOTICON MAPPING ---
        const EMOTICON_MAP = {
            "Knight": "üõ°Ô∏è",
            "Archer": "üèπ",
            "Goblins": "üíö", // Green heart for Goblins
            "Mini P.E.K.K.A.": "ü§ñ",
            "Giant": "ü¶ç",
            "Skeletons": "üíÄ",
            "Valkyrie": "ü™ì",
            "Hog Rider": "üêó",
            "Tower": "üè∞"
        };
        
        // --- CARD DEFINITION ---
        class Card {
            constructor(name, cost, color, speed, damage, health, attackRange = 0, isMelee = true, isTank = false, targetBuilding = false, isSplash = false, unitCount = 1, isSpell = false, spellRadius = 0) {
                this.name = name;
                this.cost = cost;
                this.color = color;
                this.speed = speed;
                this.damage = damage;
                this.health = health;
                this.attackRange = attackRange; 
                this.isMelee = isMelee;
                this.isTank = isTank; 
                this.targetBuilding = targetBuilding;
                this.isSplash = isSplash;
                this.unitCount = unitCount;
                this.isSpell = isSpell;
                this.spellRadius = spellRadius;
            }
        }

        const CARD_DECK_DEFINITION = [
            new Card("Knight", 3, '#007bff', 70, 80, 400),                                     
            new Card("Archer", 3, '#ff4500', 80, 40, 150, 150, false),                          
            new Card("Goblins", 2, '#4CAF50', 120, 30, 80, 0, true, false, false, false, 3), 
            new Card("Mini P.E.K.K.A.", 4, '#800080', 100, 200, 350),                           
            new Card("Giant", 5, '#00CED1', 50, 60, 800, 0, true, true),                       
            
            new Card("Skeletons", 1, '#cccccc', 150, 20, 30, 0, true, false, false, false, 4), 
            new Card("Valkyrie", 4, '#ff69b4', 90, 120, 600, 0, true, false, false, true), 
            new Card("Hog Rider", 4, '#cc5500', 130, 150, 450, 0, true, false, true), 
            new Card("Fireball", 4, '#dc143c', 0, 400, 0, 0, false, false, false, false, 1, true, 100) 
        ];
        
        const CARD_MAP = {};
        CARD_DECK_DEFINITION.forEach(card => {
            CARD_MAP[card.name] = card;
        });

        // --- Game Object Classes ---

        class Unit {
            constructor(x, y, cardData, isPlayerUnit, targetLaneX) {
                Object.assign(this, cardData); 
                this.x = x;
                this.y = y;
                this.maxHealth = this.health;
                this.width = cardData.isTank ? 40 : 30; 
                this.height = cardData.isTank ? 40 : 30;
                this.isPlayerUnit = isPlayerUnit;
                this.isDead = false;
                this.attackCooldown = 1.0; 
                this.timeSinceLastAttack = 0;
                this.targetLaneX = targetLaneX;
                this.targetUnit = null; 
            }

            draw() {
                ctx.save();
                
                // Get the emoji for the unit
                const emoji = EMOTICON_MAP[this.name] || 'üëæ';
                const teamColor = this.isPlayerUnit ? '#007bff' : '#ff4500';

                // Draw a colored background circle (optional, for team identification)
                ctx.fillStyle = teamColor;
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw the Emoji
                ctx.font = `${this.width * 0.8}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(emoji, this.x + this.width / 2, this.y + this.height / 2 + 2); // +2 for slight centering adjustment

                ctx.restore();

                // Draw Health Bar
                const healthRatio = this.health / this.maxHealth;
                ctx.fillStyle = healthRatio > 0.5 ? 'lime' : (healthRatio > 0.2 ? 'yellow' : 'red');
                ctx.fillRect(this.x, this.y - 10, this.width * healthRatio, 5);
                ctx.strokeStyle = 'black';
                ctx.strokeRect(this.x, this.y - 10, this.width, 5);
            }

            update(deltaTime) {
                if (this.health <= 0) {
                    this.isDead = true;
                    return;
                }
                
                this.timeSinceLastAttack += deltaTime;

                let currentTarget = this.targetUnit;
                let targetBuilding = null;
                let targetTower = null;

                if (currentTarget && currentTarget.isDead) {
                    this.targetUnit = null;
                    currentTarget = null;
                }
                
                if (this.targetBuilding) {
                    targetBuilding = findTargetTowerInLane(this, gameObjects.filter(obj => obj instanceof Tower && obj.isPlayerTower !== this.isPlayerUnit));
                    if (targetBuilding) {
                        this.targetUnit = null; 
                    }
                }
                
                if (currentTarget === null && !this.targetBuilding) {
                    const newTarget = findTarget(this);
                    if (newTarget) {
                        this.targetUnit = newTarget; 
                        currentTarget = newTarget;
                    }
                }
                
                if (currentTarget) {
                    const distance = calculateDistance(this, currentTarget);
                    
                    if (distance <= this.attackRange + (this.isMelee ? 10 : 0)) { 
                        if (this.timeSinceLastAttack >= this.attackCooldown) {
                            if (this.isSplash) {
                                splashAttack(this, currentTarget);
                            } else {
                                attackTarget(this, currentTarget);
                            }
                            this.timeSinceLastAttack = 0;
                        }
                    } else {
                        moveTowards(this, currentTarget.x + currentTarget.width / 2, currentTarget.y + currentTarget.height / 2, deltaTime);
                    }
                } 
                else if (targetBuilding) { 
                    const distance = calculateDistance(this, targetBuilding);
                    
                    if (distance <= this.attackRange + targetBuilding.height) { 
                        if (this.timeSinceLastAttack >= this.attackCooldown) {
                            attackTower(this, targetBuilding);
                            this.timeSinceLastAttack = 0;
                        }
                    } else {
                        moveTowards(this, targetBuilding.x + targetBuilding.width / 2, targetBuilding.y + targetBuilding.height / 2, deltaTime);
                    }
                }
                else { 
                    const towers = gameObjects.filter(obj => 
                        obj instanceof Tower && obj.isPlayerTower !== this.isPlayerUnit
                    );
                    
                    targetTower = findTargetTowerInLane(this, towers);

                    if (targetTower) {
                         const distance = calculateDistance(this, targetTower);
                         
                         if (distance <= this.attackRange + targetTower.height) { 
                             if (this.timeSinceLastAttack >= this.attackCooldown) {
                                attackTower(this, targetTower);
                                this.timeSinceLastAttack = 0;
                            }
                         } else {
                             moveTowards(this, targetTower.x + targetTower.width / 2, targetTower.y + targetTower.height / 2, deltaTime);
                         }
                    }
                }
            }
        }
        
        class Tower {
            constructor(x, y, health, color, name, isPlayerTower, lane) {
                this.x = x;
                this.y = y;
                this.health = health;
                this.maxHealth = health;
                this.color = color;
                this.name = name;
                this.isPlayerTower = isPlayerTower;
                this.lane = lane; 
                this.width = 50;
                this.height = 80;
                
                this.targetUnit = null;
                this.attackCooldown = TOWER_ATTACK_COOLDOWN;
                this.timeSinceLastAttack = 0;
            }

            draw() {
                ctx.save();
                
                // Draw tower base (solid color block)
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);

                if (this.health <= 0) {
                     // Draw rubble
                     ctx.fillStyle = '#444444'; 
                     ctx.fillRect(this.x, this.y + this.height * 0.8, this.width, this.height * 0.2); 
                     ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                     ctx.fillRect(this.x, this.y, this.width, this.height * 0.8);
                     ctx.restore();
                     return;
                }

                // Draw Emoji
                const emoji = EMOTICON_MAP["Tower"];
                
                ctx.font = `${this.width * 0.8}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(emoji, this.x + this.width / 2, this.y + this.height / 2); 
                
                ctx.restore();
                
                // Draw Health Bar
                const healthRatio = this.health / this.maxHealth;
                ctx.fillStyle = 'white';
                ctx.fillRect(this.x, this.y - 15, this.width, 10);
                ctx.fillStyle = 'darkred';
                ctx.fillRect(this.x, this.y - 15, this.width * healthRatio, 10);
                ctx.strokeStyle = 'black';
                ctx.strokeRect(this.x, this.y - 15, this.width, 10);

                ctx.fillStyle = 'white';
                ctx.font = '10px Arial';
                ctx.fillText(this.name, this.x + 5, this.y + this.height + 15);
            }
            
            update(deltaTime) {
                if (this.health <= 0) return;
                
                this.timeSinceLastAttack += deltaTime;

                if (this.targetUnit && this.targetUnit.isDead) {
                    this.targetUnit = null;
                }
                
                if (this.targetUnit === null) {
                    this.targetUnit = this.findTargetUnit();
                }

                if (this.targetUnit) {
                    const distance = calculateDistance(this, this.targetUnit);
                    
                    if (distance <= TOWER_RANGE) {
                        if (this.timeSinceLastAttack >= this.attackCooldown) {
                            this.attackUnit(this.targetUnit);
                            this.timeSinceLastAttack = 0;
                        }
                    } else {
                        this.targetUnit = null; 
                    }
                }
            }
            
            findTargetUnit() {
                const isEnemy = !this.isPlayerTower; 
                const isActive = this.isPlayerTower ? playerKingActive : enemyKingActive;

                // King Tower Check: Only attack if active
                if (this.name.includes("King") && !isActive) {
                    return null;
                }
                
                let potentialTargets = gameObjects.filter(obj => 
                    obj instanceof Unit && obj.isPlayerUnit === isEnemy
                );
                
                let closestTarget = null;
                let minDistance = TOWER_RANGE + 1;

                for (const target of potentialTargets) {
                    const distance = calculateDistance(this, target);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestTarget = target;
                    }
                }
                
                return closestTarget;
            }
            
            attackUnit(unit) {
                unit.health -= TOWER_DAMAGE;
                drawProjectile(this, unit, this.color); 
            }
        }
        
        class SpellEffect {
            constructor(x, y, radius, color, duration = 0.5) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
                this.timeRemaining = duration;
                this.isDead = false;
            }
            
            draw() {
                ctx.save();
                
                // Enhanced Fireball animation: Flashing red/yellow circle
                const flashSpeed = 10;
                const phase = Math.floor(this.timeRemaining * flashSpeed) % 2;
                const displayColor = phase === 0 ? this.color : 'yellow';
                
                ctx.fillStyle = displayColor;
                ctx.globalAlpha = this.timeRemaining * 2; 
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.globalAlpha = 1.0;
                ctx.restore();
            }
            
            update(deltaTime) {
                this.timeRemaining -= deltaTime;
                if (this.timeRemaining <= 0) {
                    this.isDead = true;
                }
            }
        }

        // --- Utility Functions ---
        
        function calculateDistance(obj1, obj2) {
            const dx = (obj1.x + obj1.width/2) - (obj2.x + obj2.width/2);
            const dy = (obj1.y + obj1.height/2) - (obj2.y + obj2.height/2);
            return Math.sqrt(dx * dx + dy * dy);
        }

        function moveTowards(unit, targetXCenter, targetYCenter, deltaTime) {
            const targetX = targetXCenter - unit.width / 2;
            const targetY = targetYCenter - unit.height / 2;

            const dx = targetX - unit.x;
            const dy = targetY - unit.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 5) {
                const dirX = dx / distance;
                const dirY = dy / distance;
                unit.x += dirX * unit.speed * deltaTime;
                unit.y += dirY * unit.speed * deltaTime;
            }
        }
        
        function findTarget(unit) {
            let potentialTargets = gameObjects.filter(obj => 
                obj instanceof Unit && obj.isPlayerUnit !== unit.isPlayerUnit
            );
            
            let closestTarget = null;
            let minDistance = Infinity;

            for (const target of potentialTargets) {
                 const distance = calculateDistance(unit, target);
                 // Check if the target is roughly in the unit's target lane
                 if (distance < minDistance && Math.abs(target.x - unit.targetLaneX) < 150) { 
                     minDistance = distance;
                     closestTarget = target;
                 }
            }
            return closestTarget;
        }

        function findTargetTowerInLane(unit, towers) {
             const laneTowers = towers.filter(t => 
                 t.lane === (unit.targetLaneX === LEFT_LANE_X_CENTER ? 'left' : 
                            unit.targetLaneX === RIGHT_LANE_X_CENTER ? 'right' : 'center')
             );
             
             // Prioritize the Princess Tower (non-center)
             let princessTower = laneTowers.find(t => t.lane !== 'center' && t.health > 0);
             if (princessTower) {
                 return princessTower;
             }
             
             // If Princess Tower is destroyed, target the King Tower (center)
             let kingTower = towers.find(t => t.lane === 'center');
             if (kingTower && kingTower.health > 0) {
                 return kingTower;
             }
             
             return null;
        }

        function attackTarget(attacker, defender) {
            defender.health -= attacker.damage;
        }
        
        function splashAttack(attacker, target) {
            const splashRadius = 50; 
            
            target.health -= attacker.damage;
            
            const secondaryTargets = gameObjects.filter(obj => 
                obj instanceof Unit && obj.isPlayerUnit !== attacker.isPlayerUnit && obj !== target && calculateDistance(target, obj) <= splashRadius
            );
            
            for (const secondaryTarget of secondaryTargets) {
                secondaryTarget.health -= attacker.damage; 
            }
        }
        
        function applyFireball(x, y, card) {
            const unitsAndTowers = gameObjects.filter(obj => 
                (obj instanceof Unit && !obj.isPlayerUnit) || (obj instanceof Tower)
            );
            
            for (const target of unitsAndTowers) {
                const targetCenterX = target.x + target.width / 2;
                const targetCenterY = target.y + target.height / 2;
                const dx = targetCenterX - x;
                const dy = targetCenterY - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance <= card.spellRadius) {
                    
                    // Activate King Tower if hit!
                    if (target.name.includes("King") && target.isPlayerTower === false && target.health === target.maxHealth) {
                        enemyKingActive = true;
                    }
                    
                    target.health -= card.damage;
                }
            }
            
            // Add the visual spell effect object to the game loop
            gameObjects.push(new SpellEffect(x, y, card.spellRadius, card.color));
        }

        function attackTower(attacker, tower) {
            
            // Activate King Tower if a Princess Tower falls
            const isPrincessTower = tower.name.includes("Left") || tower.name.includes("Right");
            
            if (isPrincessTower && tower.isPlayerTower === false) {
                 if (tower.health - attacker.damage <= 0) {
                     enemyKingActive = true;
                 }
            } else if (isPrincessTower && tower.isPlayerTower === true) {
                 if (tower.health - attacker.damage <= 0) {
                     playerKingActive = true;
                 }
            }

            // Activate King Tower if directly attacked and undamaged 
            if (tower.name.includes("King") && tower.isPlayerTower === false && tower.health === tower.maxHealth) {
                enemyKingActive = true;
            } else if (tower.name.includes("King") && tower.isPlayerTower === true && tower.health === tower.maxHealth) {
                playerKingActive = true;
            }
            
            tower.health -= attacker.damage;
            
            // Update Player King Tower UI
            const myKingTower = gameObjects.find(t => t.name === "Your King");
            if (myKingTower) {
                 document.getElementById('playerHealth').textContent = Math.max(0, myKingTower.health); 
            }
            
            if (tower.name.includes("Your King") && tower.health <= 0) {
                 endGame("DEFEAT");
            }
            
            if (tower.name.includes("Enemy King") && tower.health <= 0) {
                endGame("VICTORY");
            }
        }
        
        function endGame(result) {
            isGameOver = true;
            const modal = document.getElementById('gameOverModal');
            const modalText = document.getElementById('modalText');
            
            if (result === "VICTORY") {
                modalText.textContent = "VICTORY!";
                modal.querySelector('.modal-content').style.background = 'linear-gradient(#1e88e5, #0d47a1)';
                modal.querySelector('.modal-content').style.boxShadow = '0 0 20px rgba(0, 255, 0, 0.7)';
            } else {
                modalText.textContent = "DEFEAT!";
            }
            modal.style.display = 'flex';
        }
        
        function checkTowerStatusAndUpdateDeployment() {
            const enemyLeftTower = gameObjects.filter(obj => obj.name === "Enemy Left").find(t => t instanceof Tower);
            const enemyRightTower = gameObjects.filter(obj => obj.name === "Enemy Right").find(t => t instanceof Tower);

            // Check Left Lane
            if (enemyLeftTower && enemyLeftTower.health <= 0) {
                deploymentLines.left = DEPLOY_Y_EXPANDED; 
            } else {
                deploymentLines.left = INITIAL_DEPLOY_Y;
            }
            
            // Check Right Lane
            if (enemyRightTower && enemyRightTower.health <= 0) {
                deploymentLines.right = DEPLOY_Y_EXPANDED; 
            } else {
                deploymentLines.right = INITIAL_DEPLOY_Y;
            }
        }

        function deployUnit(x, y) {
            if (selectedCardIndex === null || isGameOver) return;
            
            const cardName = hand[selectedCardIndex];
            if (!cardName) return; 

            const card = CARD_MAP[cardName];
            
            if (elixir < card.cost) return; 
            
            let targetLane = null;
            let targetLaneX = 0;
            let currentDeployY = GAME_HEIGHT;

            // Determine which lane the click is in based on X position
            if (x >= LEFT_LANE_MIN_X && x <= LEFT_LANE_MAX_X) {
                targetLane = 'left';
                targetLaneX = LEFT_LANE_X_CENTER;
                currentDeployY = deploymentLines.left;
            } else if (x >= RIGHT_LANE_MIN_X && x <= RIGHT_LANE_MAX_X) {
                targetLane = 'right';
                targetLaneX = RIGHT_LANE_X_CENTER;
                currentDeployY = deploymentLines.right;
            }

            if (card.isSpell) {
                // Spells deploy anywhere (no lane or Y-axis check needed)
                applyFireball(x, y, card);
                elixir -= card.cost;
                replaceCardInHand(selectedCardIndex);
                setSelectedCard(null);
                return;
            }
            
            // UNIT DEPLOYMENT CHECKS:
            if (targetLane === null) return;
            if (y < currentDeployY) return; 
            
            elixir -= card.cost;
            const unitWidth = card.isTank ? 40 : 30;
            const unitHeight = card.isTank ? 40 : 30;

            for(let i = 0; i < card.unitCount; i++) {
                 const newUnit = new Unit(
                    x - unitWidth / 2 - 10 + (i * 5), 
                    y - unitHeight / 2 - 10 + (i * 5), 
                    card, 
                    true, 
                    targetLaneX 
                );
                gameObjects.push(newUnit);
            }
            
            replaceCardInHand(selectedCardIndex);
            setSelectedCard(null);
        }
        
        function replaceCardInHand(index) {
            hand[index] = deck[nextCardIndex];
            nextCardIndex = (nextCardIndex + 1) % deck.length;
            createCardButtons();
        }
        
        function spawnEnemyUnit() {
            if (isGameOver) return;
             const basicEnemyCard = CARD_MAP["Goblins"]; 
             
             const isLeft = Math.random() < 0.5;
             const spawnX = isLeft ? LEFT_LANE_X_CENTER : RIGHT_LANE_X_CENTER;
             const targetLaneX = isLeft ? LEFT_LANE_X_CENTER : RIGHT_LANE_X_CENTER;

            for(let i = 0; i < basicEnemyCard.unitCount; i++) {
                 const newEnemy = new Unit(
                    spawnX - 10 + (i * 10), 
                    130 - 10 + (i * 10), 
                    basicEnemyCard, 
                    false, 
                    targetLaneX 
                );
                gameObjects.push(newEnemy);
            }
        }

        // --- UI and Update Functions ---

        function updateElixir(deltaTime) {
            elixirTimer += deltaTime;
            if (elixirTimer >= 1) { 
                if (elixir < 10) {
                    elixir = Math.min(10, elixir + ELIXIR_REGEN_RATE);
                }
                elixirTimer = 0;
            }
            document.getElementById('elixirCount').textContent = Math.floor(elixir);
            updateCardButtons();
        }
        
        function updateEnemySpawn(deltaTime) {
            enemySpawnTimer += deltaTime;
            if (enemySpawnTimer >= ENEMY_SPAWN_RATE) {
                spawnEnemyUnit();
                enemySpawnTimer = 0;
            }
        }
        
        function handleCanvasClick(event) {
            if (selectedCardIndex !== null) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                deployUnit(x, y);
            }
        }

        function setSelectedCard(index) {
            selectedCardIndex = index;
            const buttons = document.querySelectorAll('.deploy-card');
            
            buttons.forEach((btn, i) => {
                btn.classList.remove('selected-card');
                if (i === index) {
                    btn.classList.add('selected-card');
                }
            });
        }
        
        function createCardButtons() {
            const cardDeckElement = document.getElementById('card-deck');
            const nextCardElement = document.getElementById('next-card-preview');

            cardDeckElement.innerHTML = ''; 
            
            hand.forEach((cardName, index) => {
                const card = CARD_MAP[cardName];
                const emoji = EMOTICON_MAP[cardName] || '‚ùì'; 

                const button = document.createElement('button');
                button.id = `card-slot-${index}`;
                button.className = `deploy-card card-${cardName.toLowerCase().replace(/[\s\.]/g, '')}`; 
                button.onclick = () => setSelectedCard(selectedCardIndex === index ? null : index);
                button.innerHTML = `
                    <span class="elixir-cost">${card.cost}</span>
                    <span style="font-size: 1.5em;">${emoji}</span><br>
                    ${card.name}
                `;
                cardDeckElement.appendChild(button);
            });
            
            const nextCardName = deck[nextCardIndex];
            const nextCardEmoji = EMOTICON_MAP[nextCardName] || '‚ùì';
            nextCardElement.innerHTML = `Next: ${nextCardEmoji} ${nextCardName}`;
            
            updateCardButtons();
        }
        
        function updateCardButtons() {
            hand.forEach((cardName, index) => {
                const button = document.getElementById(`card-slot-${index}`);
                const card = CARD_MAP[cardName];
                if (button) {
                    button.disabled = elixir < card.cost;
                    if (selectedCardIndex === index && elixir < card.cost) {
                         setSelectedCard(null);
                    }
                }
            });
        }
        
        function drawMap() {
            // 1. Background Grass 
            ctx.fillStyle = '#3a6639'; 
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            // 2. Stone Paths 
            const pathColor = '#5c5c5c';
            const pathWidth = 140;
            
            ctx.fillStyle = pathColor; 
            ctx.fillRect(LEFT_LANE_X_CENTER - pathWidth / 2, 0, pathWidth, GAME_HEIGHT);
            ctx.fillRect(RIGHT_LANE_X_CENTER - pathWidth / 2, 0, pathWidth, GAME_HEIGHT);

            // 3. River 
            ctx.fillStyle = '#2d5b7a'; 
            ctx.fillRect(0, MID_Y - 30, GAME_WIDTH, 60);

            // 4. Bridges 
            ctx.fillStyle = '#8f6844'; 
            const bridgeHeight = 50;
            const bridgeWidth = 120;
            ctx.fillRect(LEFT_LANE_X_CENTER - bridgeWidth / 2, MID_Y - bridgeHeight / 2, bridgeWidth, bridgeHeight);
            ctx.fillRect(RIGHT_LANE_X_CENTER - bridgeWidth / 2, MID_Y - bridgeHeight / 2, bridgeWidth, bridgeHeight);

            // 5. Deployment Zone (Player's side)
            ctx.fillStyle = 'rgba(0, 0, 150, 0.1)'; 
            
            // Left Lane Zone
            ctx.fillRect(LEFT_LANE_MIN_X, deploymentLines.left, LEFT_LANE_MAX_X - LEFT_LANE_MIN_X, GAME_HEIGHT - deploymentLines.left);
            // Right Lane Zone
            ctx.fillRect(RIGHT_LANE_MIN_X, deploymentLines.right, RIGHT_LANE_MAX_X - RIGHT_LANE_MIN_X, GAME_HEIGHT - deploymentLines.right);
            
            // 6. Deployment Lines (Visual Separator)
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            
            // Left Line
            ctx.beginPath();
            ctx.moveTo(LEFT_LANE_MIN_X, deploymentLines.left);
            ctx.lineTo(LEFT_LANE_MAX_X, deploymentLines.left);
            ctx.stroke();
            
            // Right Line
            ctx.beginPath();
            ctx.moveTo(RIGHT_LANE_MIN_X, deploymentLines.right);
            ctx.lineTo(RIGHT_LANE_MAX_X, deploymentLines.right);
            ctx.stroke();

            // 7. Detail: Center Line
            ctx.strokeStyle = '#3a3a3a'; 
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(GAME_WIDTH/2, 0);
            ctx.lineTo(GAME_WIDTH/2, GAME_HEIGHT);
            ctx.stroke();
        }
        
        function drawProjectile(source, target, color) {
            const startX = source.x + source.width / 2;
            const startY = source.y + source.height / 2;
            const endX = target.x + target.width / 2;
            const endY = target.y + target.height / 2;

            ctx.strokeStyle = 'yellow';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(endX, endY, 4, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function setupDeck() {
            fullDeck = CARD_DECK_DEFINITION.map(card => card.name);
            
            deck = [...fullDeck];
            shuffleArray(deck);
            
            hand = deck.slice(0, 4);
            
            nextCardIndex = 4 % deck.length; 
        }


        function initGame() {
            setupDeck();
            
            // Opponent Towers (Top)
            gameObjects.push(new Tower(LEFT_LANE_X_CENTER - 25, 150, 1000, 'red', "Enemy Left", false, 'left'));
            gameObjects.push(new Tower(RIGHT_LANE_X_CENTER - 25, 150, 1000, 'red', "Enemy Right", false, 'right'));
            // Enemy King starts passive (health=2000)
            gameObjects.push(new Tower(CENTER_LANE_X - 25, 50, 2000, 'red', "Enemy King", false, 'center')); 
            
            // Player Towers (Bottom)
            gameObjects.push(new Tower(LEFT_LANE_X_CENTER - 25, GAME_HEIGHT - 220, 1000, 'blue', "Your Left", true, 'left'));
            gameObjects.push(new Tower(RIGHT_LANE_X_CENTER - 25, GAME_HEIGHT - 220, 1000, 'blue', "Your Right", true, 'right'));
            // Player King starts passive (health=2000)
            gameObjects.push(new Tower(CENTER_LANE_X - 25, GAME_HEIGHT - 120, 2000, 'blue', "Your King", true, 'center')); 
            
            createCardButtons();
            canvas.addEventListener('click', handleCanvasClick);
        }


        // --- Main Game Loop ---
        function gameLoop(timestamp) {
            if (isGameOver) {
                return; 
            }
            
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            // Check and update the valid deployment zone
            checkTowerStatusAndUpdateDeployment();

            drawMap(); 

            updateElixir(deltaTime);
            updateEnemySpawn(deltaTime); 
            
            // Filter gameObjects: process Units/Towers first, then SpellEffects
            const unitsAndTowers = gameObjects.filter(obj => obj instanceof Unit || obj instanceof Tower);
            const spellEffects = gameObjects.filter(obj => obj instanceof SpellEffect);
            
            // Update Towers and Units
            for (const obj of unitsAndTowers) {
                obj.update(deltaTime);
            }
            
            // Update Spell Effects
            for (const obj of spellEffects) {
                obj.update(deltaTime);
            }

            // Cleanup dead units and expired spell effects
            for (let i = gameObjects.length - 1; i >= 0; i--) {
                const obj = gameObjects[i];
                if ((obj instanceof Unit && obj.isDead) || (obj instanceof SpellEffect && obj.isDead)) {
                    gameObjects.splice(i, 1);
                }
            }

            // Draw all remaining objects
            for (const obj of gameObjects) {
                obj.draw();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Start the game!
        initGame();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
