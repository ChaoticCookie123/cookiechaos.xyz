<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple JS Clash Clone (Full Combat & Cards)</title>
    
    <style>
        /* --- CSS Styling --- */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #333;
            font-family: 'Arial', sans-serif;
            flex-direction: column;
        }

        #game-container {
            border: 8px solid #a97e4b; 
            position: relative;
            background-color: #6a9c37; 
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.6);
            border-radius: 10px;
        }

        #gameCanvas {
            display: block;
            cursor: pointer;
        }

        #ui-overlay {
            width: 100%;
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 10px 0;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            position: absolute;
            bottom: 0;
            left: 0;
            box-sizing: border-box;
            border-top: 2px solid #555;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
        }
        
        #ui-overlay p {
            margin: 0 10px;
            font-size: 1.1em;
            display: flex;
            align-items: center;
        }
        
        .icon {
            font-size: 1.5em;
            margin-right: 5px;
        }

        #card-deck {
            display: flex;
            gap: 5px; 
        }
        
        .deploy-card {
            padding: 8px 5px; 
            color: white;
            font-weight: bold;
            border: 3px solid #ffd700;
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.2s, box-shadow 0.1s;
            box-shadow: 0 4px #c43500;
            margin: 5px;
            min-width: 65px; 
            text-align: center;
            line-height: 1.1;
            font-size: 0.85em; 
        }
        
        .deploy-card:disabled {
            background-color: #555 !important;
            border-color: #333;
            cursor: not-allowed;
            box-shadow: none;
            color: #ccc;
        }
        
        .deploy-card:not(:disabled):active {
            box-shadow: 0 2px #c43500;
            transform: translateY(2px);
        }
        
        /* Specific Card Styles */
        #card0 { background-color: #007bff; } 
        #card1 { background-color: #ff4500; } 
        #card2 { background-color: #4CAF50; } 
        #card3 { background-color: #800080; } 
        #card4 { background-color: #00CED1; } 
        
        .selected-card {
            box-shadow: 0 0 15px 5px yellow !important;
            border-color: yellow !important;
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    
    <h1>‚öîÔ∏è Strategic Clash Clone</h1>

    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="ui-overlay">
            <p><span class="icon">‚ù§Ô∏è</span> King Tower: <span id="playerHealth">2000</span></p>
            
            <div id="card-deck">
                </div>
            
            <p><span class="icon">üß™</span> Elixir: <span id="elixirCount">10</span>/10</p>
        </div>
    </div>

    <script>
        // --- Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const GAME_WIDTH = canvas.width;
        const GAME_HEIGHT = canvas.height;
        const MID_Y = GAME_HEIGHT / 2;
        const DEPLOY_LINE_Y = GAME_HEIGHT * 0.6; 
        const LEFT_LANE_X = GAME_WIDTH * 0.25; 
        const RIGHT_LANE_X = GAME_WIDTH * 0.75; 
        const CENTER_LANE_X = GAME_WIDTH * 0.5;

        // --- Game State Variables ---
        let playerHealth = 2000;
        let elixir = 10;
        let lastTime = 0;
        let elixirTimer = 0;
        let enemySpawnTimer = 0; 
        const ELIXIR_REGEN_RATE = 1; 
        const ENEMY_SPAWN_RATE = 5; 
        let selectedCardIndex = null; 

        const gameObjects = []; 

        // --- CARD DEFINITION ---
        class Card {
            constructor(name, cost, color, speed, damage, health, attackRange = 0, isMelee = true, isTank = false) {
                this.name = name;
                this.cost = cost;
                this.color = color;
                this.speed = speed;
                this.damage = damage;
                this.health = health;
                this.attackRange = attackRange; 
                this.isMelee = isMelee;
                this.isTank = isTank; 
            }
        }

        const CARD_DECK = [
            new Card("Knight", 3, '#007bff', 70, 80, 400),                                     
            new Card("Archer", 3, '#ff4500', 80, 40, 150, 150, false),                          
            new Card("Goblins", 2, '#4CAF50', 120, 30, 80),                                    
            new Card("Mini P.E.K.K.A.", 4, '#800080', 100, 200, 350),                           
            new Card("Giant", 5, '#00CED1', 50, 60, 800, 0, true, true),                       
        ];

        // --- Game Object Classes ---

        class Unit {
            constructor(x, y, cardData, isPlayerUnit, targetLaneX) {
                Object.assign(this, cardData); 
                this.x = x;
                this.y = y;
                this.maxHealth = this.health;
                this.width = cardData.isTank ? 40 : 30; 
                this.height = cardData.isTank ? 40 : 30;
                this.isPlayerUnit = isPlayerUnit;
                this.isDead = false;
                this.attackCooldown = 1.0; 
                this.timeSinceLastAttack = 0;
                this.targetLaneX = targetLaneX;
                
                // Target lock variable
                this.targetUnit = null; 
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                const healthRatio = this.health / this.maxHealth;
                ctx.fillStyle = healthRatio > 0.5 ? 'lime' : (healthRatio > 0.2 ? 'yellow' : 'red');
                ctx.fillRect(this.x, this.y - 10, this.width * healthRatio, 5);
                ctx.strokeStyle = 'black';
                ctx.strokeRect(this.x, this.y - 10, this.width, 5);
            }

            update(deltaTime) {
                if (this.health <= 0) {
                    this.isDead = true;
                    return;
                }
                
                this.timeSinceLastAttack += deltaTime;

                let currentTarget = this.targetUnit;
                let targetTower = null;

                // 1. Check if the locked target is still alive
                if (currentTarget && currentTarget.isDead) {
                    this.targetUnit = null;
                    currentTarget = null;
                }

                // 2. If no target is locked, search for a new enemy unit
                if (currentTarget === null) {
                    const newTarget = findTarget(this);
                    if (newTarget) {
                        this.targetUnit = newTarget; // Lock onto the new target
                        currentTarget = newTarget;
                    }
                }

                // --- Combat/Movement Logic ---

                if (currentTarget) {
                    const distance = calculateDistance(this, currentTarget);
                    
                    if (distance <= this.attackRange + (this.isMelee ? 10 : 0)) { 
                        // ATTACKING UNIT
                        if (this.timeSinceLastAttack >= this.attackCooldown) {
                            attackTarget(this, currentTarget);
                            this.timeSinceLastAttack = 0;
                        }
                    } else {
                        // MOVING TO UNIT
                        moveTowards(this, currentTarget.x + currentTarget.width / 2, currentTarget.y + currentTarget.height / 2, deltaTime);
                    }

                } else {
                    // NO UNIT TARGET: Target Tower
                    const towers = gameObjects.filter(obj => 
                        obj instanceof Tower && obj.isPlayerTower !== this.isPlayerUnit
                    );
                    
                    targetTower = findTargetTowerInLane(this, towers);

                    if (targetTower) {
                         const distance = calculateDistance(this, targetTower);
                         
                         if (distance <= this.attackRange + targetTower.height) { 
                             // ATTACKING TOWER
                             if (this.timeSinceLastAttack >= this.attackCooldown) {
                                attackTower(this, targetTower);
                                this.timeSinceLastAttack = 0;
                            }
                         } else {
                             // MOVING TO TOWER
                             moveTowards(this, targetTower.x + targetTower.width / 2, targetTower.y + targetTower.height / 2, deltaTime);
                         }
                    }
                }
            }
        }
        
        function calculateDistance(obj1, obj2) {
            const dx = (obj1.x + obj1.width/2) - (obj2.x + obj2.width/2);
            const dy = (obj1.y + obj1.height/2) - (obj2.y + obj2.height/2);
            return Math.sqrt(dx * dx + dy * dy);
        }

        function moveTowards(unit, targetXCenter, targetYCenter, deltaTime) {
            const targetX = targetXCenter - unit.width / 2;
            const targetY = targetYCenter - unit.height / 2;

            const dx = targetX - unit.x;
            const dy = targetY - unit.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 5) {
                const dirX = dx / distance;
                const dirY = dy / distance;
                unit.x += dirX * unit.speed * deltaTime;
                unit.y += dirY * unit.speed * deltaTime;
            }
        }


        class Tower {
            constructor(x, y, health, color, name, isPlayerTower, lane) {
                this.x = x;
                this.y = y;
                this.health = health;
                this.maxHealth = health;
                this.color = color;
                this.name = name;
                this.isPlayerTower = isPlayerTower;
                this.lane = lane; 
                this.width = 50;
                this.height = 80;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                const healthRatio = this.health / this.maxHealth;
                ctx.fillStyle = 'white';
                ctx.fillRect(this.x, this.y - 15, this.width, 10);
                ctx.fillStyle = 'darkred';
                ctx.fillRect(this.x, this.y - 15, this.width * healthRatio, 10);
                ctx.strokeStyle = 'black';
                ctx.strokeRect(this.x, this.y - 15, this.width, 10);

                ctx.fillStyle = 'white';
                ctx.font = '10px Arial';
                ctx.fillText(this.name, this.x + 5, this.y + this.height + 15);
            }
        }

        // --- Game Logic Functions ---
        
        function findTarget(unit) {
            let potentialTargets = gameObjects.filter(obj => 
                obj instanceof Unit && obj.isPlayerUnit !== unit.isPlayerUnit
            );
            
            let closestTarget = null;
            let minDistance = Infinity;

            for (const target of potentialTargets) {
                 const distance = calculateDistance(unit, target);
                 // Only consider targets near the unit's lane
                 if (distance < minDistance && Math.abs(target.x - unit.targetLaneX) < 150) { 
                     minDistance = distance;
                     closestTarget = target;
                 }
            }
            return closestTarget;
        }

        function findTargetTowerInLane(unit, towers) {
             const laneTowers = towers.filter(t => 
                 t.lane === (unit.targetLaneX === LEFT_LANE_X ? 'left' : 
                            unit.targetLaneX === RIGHT_LANE_X ? 'right' : 'center')
             );
             
             // 1. Target Princess Tower first
             let princessTower = laneTowers.find(t => t.lane !== 'center' && t.health > 0);
             if (princessTower) {
                 return princessTower;
             }
             
             // 2. Fallback to King Tower
             let kingTower = towers.find(t => t.lane === 'center');
             if (kingTower && kingTower.health > 0) {
                 return kingTower;
             }
             
             return null;
        }

        function attackTarget(attacker, defender) {
            defender.health -= attacker.damage;
        }

        function attackTower(attacker, tower) {
            tower.health -= attacker.damage;
            
            if (tower.name.includes("Your")) {
                document.getElementById('playerHealth').textContent = Math.max(0, tower.health); 
            }
            
            if (tower.health <= 0) {
                alert(`${tower.name} destroyed! ${tower.isPlayerTower ? "Game Over! You Lose." : "Tower Down!"}`);
            }
        }

        function deployUnit(x, y) {
            if (selectedCardIndex === null) return;
            
            const card = CARD_DECK[selectedCardIndex];
            if (elixir < card.cost || y < DEPLOY_LINE_Y) return;

            elixir -= card.cost;
            
            let targetLaneX = x < GAME_WIDTH / 2 ? LEFT_LANE_X : RIGHT_LANE_X;
            
            // Fix applied here: Calculate unit dimensions correctly
            const unitWidth = card.isTank ? 40 : 30;
            const unitHeight = card.isTank ? 40 : 30;

            if (card.name === "Goblins") {
                for(let i = 0; i < 3; i++) {
                     const newUnit = new Unit(
                        x - 15 + (i * 10), 
                        y - 15 + (i * 10), 
                        card, 
                        true, 
                        targetLaneX 
                    );
                    gameObjects.push(newUnit);
                }
            } else {
                 const newUnit = new Unit(
                    x - unitWidth / 2, 
                    y - unitHeight / 2,
                    card, 
                    true, 
                    targetLaneX 
                );
                gameObjects.push(newUnit);
            }
            
            setSelectedCard(null);
        }
        
        function spawnEnemyUnit() {
             const basicEnemyCard = CARD_DECK.find(c => c.name === "Goblins");
             
             const isLeft = Math.random() < 0.5;
             const spawnX = isLeft ? LEFT_LANE_X : RIGHT_LANE_X;
             const targetLaneX = isLeft ? LEFT_LANE_X : RIGHT_LANE_X;

            const newEnemy = new Unit(
                spawnX, 
                130, 
                basicEnemyCard, 
                false, 
                targetLaneX 
            );
            gameObjects.push(newEnemy);
        }

        function updateElixir(deltaTime) {
            elixirTimer += deltaTime;
            if (elixirTimer >= 1) { 
                if (elixir < 10) {
                    elixir = Math.min(10, elixir + ELIXIR_REGEN_RATE);
                }
                elixirTimer = 0;
            }
            document.getElementById('elixirCount').textContent = Math.floor(elixir);
            updateCardButtons();
        }
        
        function updateEnemySpawn(deltaTime) {
            enemySpawnTimer += deltaTime;
            if (enemySpawnTimer >= ENEMY_SPAWN_RATE) {
                spawnEnemyUnit();
                enemySpawnTimer = 0;
            }
        }
        
        function handleCanvasClick(event) {
            if (selectedCardIndex !== null) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                deployUnit(x, y);
            }
        }

        function setSelectedCard(index) {
            selectedCardIndex = index;
            const buttons = document.querySelectorAll('.deploy-card');
            
            buttons.forEach((btn, i) => {
                btn.classList.remove('selected-card');
                if (i === index) {
                    btn.classList.add('selected-card');
                }
            });
        }
        
        function createCardButtons() {
            const cardDeckElement = document.getElementById('card-deck');
            
            CARD_DECK.forEach((card, index) => {
                const button = document.createElement('button');
                button.id = `card${index}`;
                button.className = 'deploy-card';
                button.onclick = () => setSelectedCard(selectedCardIndex === index ? null : index);
                button.innerHTML = `
                    ${card.name} <br> 
                    <span class="icon">üß™ ${card.cost}</span>
                `;
                cardDeckElement.appendChild(button);
            });
        }
        
        function updateCardButtons() {
            CARD_DECK.forEach((card, index) => {
                const button = document.getElementById(`card${index}`);
                if (button) {
                    button.disabled = elixir < card.cost;
                    if (selectedCardIndex === index && elixir < card.cost) {
                         setSelectedCard(null);
                    }
                }
            });
        }
        
        function drawMap() {
            ctx.fillStyle = '#6a9c37';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            ctx.fillStyle = 'rgba(0, 0, 150, 0.1)';
            ctx.fillRect(0, DEPLOY_LINE_Y, GAME_WIDTH, GAME_HEIGHT - DEPLOY_LINE_Y);
            
            ctx.fillStyle = '#4c5d88'; 
            ctx.fillRect(0, MID_Y - 20, GAME_WIDTH, 40);

            ctx.fillStyle = '#a97e4b'; 
            const bridgeHeight = 40;
            const bridgeWidth = 100;
            ctx.fillRect(LEFT_LANE_X - bridgeWidth / 2, MID_Y - bridgeHeight / 2, bridgeWidth, bridgeHeight);
            ctx.fillRect(RIGHT_LANE_X - bridgeWidth / 2, MID_Y - bridgeHeight / 2, bridgeWidth, bridgeHeight);

            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, DEPLOY_LINE_Y);
            ctx.lineTo(GAME_WIDTH, DEPLOY_LINE_Y);
            ctx.stroke();
        }


        function initGame() {
            // Opponent Towers (Top)
            gameObjects.push(new Tower(CENTER_LANE_X - 25, 20, 2000, 'red', "Enemy King", false, 'center'));
            gameObjects.push(new Tower(LEFT_LANE_X - 25, 120, 1000, 'red', "Enemy Left", false, 'left'));
            gameObjects.push(new Tower(RIGHT_LANE_X - 25, 120, 1000, 'red', "Enemy Right", false, 'right'));
            
            // Player Towers (Bottom)
            gameObjects.push(new Tower(CENTER_LANE_X - 25, GAME_HEIGHT - 100, 2000, 'blue', "Your King", true, 'center'));
            gameObjects.push(new Tower(LEFT_LANE_X - 25, GAME_HEIGHT - 200, 1000, 'blue', "Your Left", true, 'left'));
            gameObjects.push(new Tower(RIGHT_LANE_X - 25, GAME_HEIGHT - 200, 1000, 'blue', "Your Right", true, 'right'));
            
            createCardButtons();
            canvas.addEventListener('click', handleCanvasClick);
        }


        // --- Main Game Loop ---
        function gameLoop(timestamp) {
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            drawMap(); 

            updateElixir(deltaTime);
            updateEnemySpawn(deltaTime); 
            
            for (let i = gameObjects.length - 1; i >= 0; i--) {
                const obj = gameObjects[i];
                if (obj instanceof Unit) {
                    obj.update(deltaTime);
                    if (obj.isDead) {
                        gameObjects.splice(i, 1);
                    }
                }
            }

            for (const obj of gameObjects) {
                obj.draw();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Start the game!
        initGame();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
